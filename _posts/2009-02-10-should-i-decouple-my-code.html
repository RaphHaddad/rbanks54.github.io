---
layout: post
title: Should I Decouple My Code?
date: '2009-02-10T16:03:00.001+11:00'
author: Richard Banks
tags:
- design
- agile
- development
modified_time: '2009-02-10T16:03:11.222+11:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-5028087497056964050
blogger_orig_url: http://www.richard-banks.org/2009/02/should-i-decouple-my-code.html
---

<p>If you look around the internet you’ll find lots of information on refactoring your code, making it more testable, improving its maintainability, and using DI/IoC techniques to increase the ease in which you can make changes to it.&#160; A very large element in all these subjects is having code that is loosely coupled and learning how to take existing tightly coupled code and improve it.</p>  <p>That’s great…. and making these changes is a laudable goal, but what do you do when you look at the code you work on each and every day and you see how tightly coupled it is and then look at just how many more changes and features your customers are asking you to add and make to your application.&#160; You know you want to clean things up to make it easier to get through that backlog of requests but when is it right to decouple and when is it OK to leave code as is?&#160; It’s a valid concern and was asked as a follow up to my screen cast on <a href="http://richardsbraindump.blogspot.com/2009/01/decoupling-your-code-by-example.html" target="_blank">Decoupling Your Code by Example</a>.</p>  <p>So first, let’s be clear; tightly coupled code is a form of <a href="http://richardsbraindump.blogspot.com/2008/06/technical-debt-aka-code-debt.html" target="_blank">technical debt</a> that will decrease your ability to quickly and cleanly make changes to an existing code base and thus slows the rate at which you can get through that backlog of customer requests.&#160; And since those customers making the requests are in all likelihood the same ones that end up paying your wages then it’s probably a good idea to go as quickly as you can.</p>  <p>OK, fine; but now let’s consider the agile principles of not wasting effort and delivering business value to the customer as quickly as possible. If we have an existing code base that is full of tight couplings then we can’t very well ask our customer for x-weeks of time to let us refactor the internals of the application to reduce coupling.&#160; It’ll would add zero business value to the customer because in x-weeks we would have delivered zero new functionality.&#160; We would also very likely be changing parts of the application that are not going to see any changes in the future – thus it would include wasted effort.</p>  <p>It’s therefor pretty logical that we really only want to decouple code when we’re actively changing it.&#160; We should apply the boy scout rule and “leave the campsite better than we found it”, or in our case, the code base.&#160; Also, we don’t want to go fixing stuff up that we aren’t currently changing, no matter how ugly it is or how tempting it is to improve it – if we do we are only slowing down our development efforts on the items we need to be delivering now, items which our customer is expecting.&#160; In doing so we also run an increased risk of introducing new bugs.&#160; Why? Well, if we only have a certain amount of time to finish something then we really don’t have enough time to do a proper clean up of things outside of the area we are currently working on. So we’ll probably do what most of us do when time is short; make a change that we think is OK (but isn’t) and we won’t worry too much about the tests.</p>  <p>The agile principle of wasted effort can also come into play when looking at coupled code in an area of the application we are actively changing.&#160; Some tight coupling just isn’t worth the time and effort to change.&#160; Let’s say we have a tight coupling to ADO.NET which makes our code a bit clunky in places. It’s awkward at times to use and we could be faster if we changed it, but is it really worth x-weeks to rework our code to use an improved data access mechanism just so we can have a more loosely coupled design? Is there enough payback in making that change that it benefits the customer directly, or even indirectly by saving us more than x-weeks worth of effort further down the track? Maybe; maybe not.&#160; In most cases probably not.&#160; And if the payback isn’t there, then don’t make the change.</p>  <p>So, should you decouple your code?&#160; The answer is, like all things in software development: <em>it depends</em>. These two questions can probably help you make that call.</p>  <ul>   <li>Is the decoupling in an area of the system I’m currently working on? </li>    <li>Will the time spend changing the code more than pay for itself with time savings later? </li> </ul>  <p>If you can answer “Yes” to both of those, then it’s probably time to decouple your code.&#160; If you can’t, then get on with giving your customer what they asked for – new features in their application.</p>  