---
layout: post
title: 'Mocking Comparison – Part 8: Recursive Mocks'
date: '2010-07-29T21:21:00.002+10:00'
author: Richard Banks
tags:
- mocking
modified_time: '2010-08-06T08:56:22.435+10:00'
thumbnail: http://lh6.ggpht.com/_5dD_rBQSs2o/TEz6r2K-_OI/AAAAAAAAAxg/bgdjXZf3tfY/s72-c/image_thumb%5B2%5D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-13321238.post-638366900969220881
blogger_orig_url: http://www.richard-banks.org/2010/07/mocking-comparison-part-8-recursive.html
---

<p>Recursive mocks (or nested mocks as some people call them) are a feature of the mocking frameworks where they will automatically create mock objects for items they should return if you reference a property or method of that object when setting up expectations.&#160; The advantages of doing this are that we have less “arrange” code in our test classes and can focus our efforts more on our act and assert code.</p>  <p>Maybe that explanation of recursive mocks doesn’t clarify things much for you so let’s just look at some code instead and see how Rhino Mocks, Moq and NSubstitute help us out.</p><h3>Rhino Mocks</h3><div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:574a1199-d20e-4c92-8a69-a8cbd043b535" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Rhino_recursive_mocks()<br />{<br /> var monkey = MockRepository.GenerateStub&lt;IMonkey&gt;();<br /> monkey.Name = "Spike";<br /> monkey.Stub(m =&gt; m.Keeper().AssignedMonkey).Return(monkey);<br /> Assert.NotNull(monkey.Keeper());<br /> Assert.Equal("Spike", monkey.Keeper().AssignedMonkey.Name);<br />}<br /></pre></div><p>If you have a look at the code you can see that we create a stub object for the the IMonkey interface.&#160; Within that we set up an expectation that when we check which monkey the keeper is assigned to that it should be the monkey object we just created (i.e. we’re setting up a circular object reference).</p><p>We don’t need to create a specific IZooKeeper stub object here as Rhino will do that for us and if you step through the test in debug mode you can see that we have a fake object created for us:</p><p><a href="http://lh4.ggpht.com/_5dD_rBQSs2o/TEz6qkNRYSI/AAAAAAAAAxc/qSGSiPg1BcQ/s1600-h/image%5B4%5D.png"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="image" border="0" alt="image" src="http://lh6.ggpht.com/_5dD_rBQSs2o/TEz6r2K-_OI/AAAAAAAAAxg/bgdjXZf3tfY/image_thumb%5B2%5D.png?imgmax=800" width="480" height="134" /></a></p><h3>Moq</h3><p>The code for Moq is much the same apart from the fact that we have to set up the property behaviour for the monkey’s name and remember if we’re dealing with the mock or the object it’s returning.</p><p><div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:e3bfd2ee-282e-4917-b33c-c5405db3c644" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Moq_recursive_mocks()<br />{<br /> var monkey = new Mock&lt;IMonkey&gt;();<br /> monkey.Setup(m =&gt; m.Keeper().AssignedMonkey).Returns(monkey.Object);<br /> monkey.SetupProperty(m =&gt; m.Name);<br /> monkey.Object.Name = "Spike";<br /> Assert.NotNull(monkey.Object.Keeper());<br /> Assert.Equal("Spike", monkey.Object.Keeper().AssignedMonkey.Name);<br />}<br /></pre></div></p><p>Interestingly, if you look at the code in the final assert closely you’ll see that the mock/object distinction is lost when we start using the recursive mocks.&#160; Instead of using Keeper().Object.AssignedMonkey we just have Keeper().AssignedMonkey.&#160; It’s not a big deal, but it seems to break the paradigm that Moq has used elsewhere of separating the Mock from the object itself.</p><h3>NSubstitute</h3><p>And finally the NSubstitute approach</p><div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:24b917bc-c43c-4e47-9395-8aa37d38991b" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Nsubstitute_recursive_mocks()<br />{<br /> var monkey = Substitute.For&lt;IMonkey&gt;();<br /> monkey.Keeper().AssignedMonkey.Returns(monkey);<br /> monkey.Name = "Spike";<br /> Assert.NotNull(monkey.Keeper());<br /> Assert.Equal("Spike", monkey.Keeper().AssignedMonkey.Name);<br />}<br /></pre></div><p>Nice and clean.&#160; No lambdas. Expressive and direct.&#160; What more could you want :-)</p><p>P.S. At time of writing the recursive behaviour was only available when building from source.</p><p>&#160;</p><p>The verdict? NSubstitute is the clear winner here.</p><p>&nbsp;</p><p>Other posts in this series:<ul><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-1-basics.html">1: The Basics</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-2-properties.html">2: Properties</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-3-interactions.html">3: Interactions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-4-parameter.html">4: Parameter Constraints</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-5-repetitions.html">5: Repetitions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-6-multiple.html">6: Multiple Calls</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-7-exceptions.html">7: Exceptions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-9-functions.html">9: Functions</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-10-events.html">10: Events</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-11-multiple.html">11: Multiple Interfaces</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-12-unmockables.html">12: The UnMockables</a></li></ul></p>