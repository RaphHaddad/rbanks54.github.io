---
layout: post
title: Should I Unit Test Private Methods?
date: '2008-08-04T20:21:00.001+10:00'
author: Richard Banks
tags: 
modified_time: '2008-08-04T20:21:17.350+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-1869256518539022082
blogger_orig_url: http://www.richard-banks.org/2008/08/should-i-unit-test-private-methods.html
---

<p>I was talking with a team last week about unit testing and TDD and the question came up as to whether private methods should be tested.&nbsp; I immediately said "no way" without any hesitation and was really surprised at the reaction from some of the team.&nbsp; We had a very interesting chat about it, and I thought I'd put down my thinking here as well to see what you think.</p> <p>Firstly I see unit testing as black box testing.&nbsp; We should test our classes through their public and internal methods - i.e. from the viewpoint of a consumer of of the class; without any understanding of how that functionality may be implemented internally.</p> <p>Next, the only reason for a class to have private methods is to support the public and internal methods of that class.&nbsp; If there are private methods that aren't reached through public or internal methods then you have dead code and it should be removed.&nbsp; Similarly, if you can't hit all of the code in your private methods through the public/internal methods then you have dead code in your method and it, likewise, needs to be removed.</p> <p>Now, in order to test private methods your code needs to have some way of exposing those private methods to the test classes, meaning they can't actually be private methods in all situations.&nbsp; They need to be private for release builds, but accessible for test builds.&nbsp; You can try using compiler directives or some other mechanism to control accessibility however this is error prone and it's easy to accidentally release a version of an assembly with the private methods exposed as internal or public methods.&nbsp; More often though you'll simply see people writing exposing methods that really should be private just to make it easier to test.&nbsp; Not a design choice.</p> <p>Further, tying tests to private methods makes your tests brittle.&nbsp; If start to refactor a class I should be free to make changes to the private methods without impacting the externally exposed functionality of the class.&nbsp; For example, if I rename an internal or public method I would expect tests to fail, but renaming a private method should have no impact on the tests and I would expect that they should continue to function correctly.</p> <p>For me these reasons are reason enough.</p> <p>&nbsp;</p> <p>So why would you want to test a private method?&nbsp; The argument is something like this <em>"If my public method does a lot of work - e.,g. setting up connections to databases and so forth, and my private method is just doing a small piece of logic then I want to test that the logic is correct without needing to go through all the other work."</em>&nbsp; It sounds like a reasonable argument but it's an argument that's only required when poor design decisions have been made.</p> <p>A well designed class will do one thing and one thing only (the single concern principle) and will call out to other classes for functionality such as connecting to databases or file systems, etc.&nbsp; By using dependency injection and programming to interfaces you can make testing much simpler by passing mock objects to the class under test without actually needing to do the work of connecting to a database for instance.&nbsp; Not only does this help with the separation of concerns principle, but it also means my unit tests will actually be unit tests and not integration tests.&nbsp; And by using mock objects they'll also be a lot faster to run. </p> <p>&nbsp;</p> <p>So, what do you think? Leave a comment if you agree or disagree.&nbsp; I'd like to hear your thoughts on the subject.</p>  