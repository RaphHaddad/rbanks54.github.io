---
layout: post
title: Raising Events With Rhino Mocks AAA Syntax
date: '2009-11-16T10:40:00.002+11:00'
author: Richard Banks
tags:
- how to
- ".net"
- testing
- open source
- development
modified_time: '2009-11-16T10:50:03.735+11:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-3173981037548319879
blogger_orig_url: http://www.richard-banks.org/2009/11/raising-events-with-rhino-mocks-aaa.html
---

There’s various posts on the web showing how to raise events in Rhino Mocks but they typically show you how to do it using the Record/Replay syntax, which I personally find quite awkward.<br /><br />I was just helping out someone today and showing them how to do it using the Arrange, Act, Assert (AAA) syntax in Rhino Mocks 3.5 and I thought you might be interested in know how to do this as well.<br /><br />Let’s start with a basic scenario… let’s assume that in our class under test we wanting to check that when we call a method on another object, that it will raise a CancelEvent and we can listen to that event and take action as appropriate.&nbsp; I like to test behaviour in my classes, so in my test I want to be sure that my class under test correctly subscribes to the event and that it will set the cancel flag correctly..<br /><br />Here’s some code.<br /><pre class="brush:csharp">public interface IProcessor<br />{<br /> string AMethodThatRaisesAnEvent(int value);<br /> event EventHandler&lt;CancelEventArgs&gt; AboutToProcess;<br />}<br /><br />public class EventListener<br />{<br />    IProcessor processor;<br />    public EventListener(IProcessor processor)<br />    {<br />        this.processor = processor;<br />        this.processor.AboutToProcess += HandleTheEvent;<br />    }<br /><br />    public string MakeItHappen()<br />    {<br />        return processor.AMethodThatRaisesAnEvent(0);<br />    }<br /><br />    public void HandleTheEvent(object sender, CancelEventArgs args)<br />    {<br />        if (sender is IProcessor)<br />        {<br />            args.Cancel = true;<br />        }<br />        return;<br />    }<br />}</pre>So as we can see, the constructor takes in the processor object and starts listening for the AboutToProcess event.&nbsp; When it fires it checks the senders type and and sets the Cancel flag.&nbsp; It’s a silly thing to do in reality since normally you would check property values on the sender and decide wether to cancel or not, but for the purposes of the post, it will do.<br /><br />Now let’s write our behaviour test.<br /><pre class="brush:csharp">[Test]<br />public void TheEventListenerShouldCauseProcessingToBeCancelled()<br />{<br />    var processor = MockRepository.GenerateStub&lt;IProcessor&gt;();<br />    var args = new CancelEventArgs();<br />    var listener = new EventListener(processor);<br />    processor.Stub(p =&gt; p.AMethodThatRaisesAnEvent(0)).IgnoreArguments()<br />        .Do(new Func&lt;int , string&gt;(value =&gt;<br />                {<br />                    processor.Raise(x =&gt; x.AnEvent += null, processor, args);<br />                    Assert.IsTrue(args.Cancel);<br />                    return string.Empty;<br />                }));<br />    listener.MakeItHappen();<br />}</pre>So what’s happening here?<br /><br />In the first few lines we arrange the objects we want for the test, then we get into the juicy bit.<br /><br />It may look a little scary but if you break it down into it’s components, it’s actually prettty easy to grok.&nbsp; First we set up a stub for when the AMethodThatRaisesAnEvent() is called.&nbsp; We ignore any argument values that may be passed into it and we then supply a method implementation using Rhino’s Do() method.<br /><br />Inside Do we supply a new function that takes an int as a parameter and returns a string – the same signature as the AMethodThatRaisesAnEvent() method that we are stubbing.&nbsp; Inside it we Raise() the event we want to fire and have an Assert that will check if the Cancel flag has been set to true.&nbsp; Note that we also need to supply a return value otherwise the code won’t compile.<br /><br />Look a little closer at the Raise() method.&nbsp; You’ll see that you don’t just say what event to raise, you actually supply a lambda that subscribes to the event you want to raise.&nbsp; It looks a little wierd but it’s a workaround for the language limitations.&nbsp; The second two parameters are the event sender and eventargs parameters.<br /><br />Finally we make a call on our class under tests MakeItHappen() method.&nbsp; There’s no asserts aftrer that because we are only wanting to check the event handling behaviour, not the return value from the mock object.&nbsp; Also, if you set a breakpoint inside the Do method, you’ll see that the event raising happens after the MakeItHappen() call, even though it appears before it in the source.<br /><br />And there you have it – raising events from mock objects using Rhino Mocks.<br /><br />P.S. Some of you will have noticed that I’m using Stubs instead of Mocks.&nbsp; This is because I’m not asserting anything on the fake object itself and I’m simply stubbing out code.&nbsp; Please don’t get too hung up on this.&nbsp; There’s a whole world of pointless arguments about what to call fake objects; stubs, mocks, fakes, whatever.&nbsp; I certainly don’t care and the code works just the same if you use GenerateMock and processor.Expect() so do what you’re comfortable with and ignore the storm in a teacup argument over what to call them.<br />