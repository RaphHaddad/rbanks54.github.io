---
layout: post
title: How To Use the Windows Workflow Rules Engine By Itself
date: '2007-08-27T22:04:00.001+10:00'
author: Richard Banks
tags:
- readify
- workflow
modified_time: '2014-06-23T02:15:27.786+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-4779882437922693704
blogger_orig_url: http://www.richard-banks.org/2007/08/how-to-use-windows-workflow-rules.html
---

<a href="http://wf.netfx3.com/">Windows Workflow Foundation</a> (WF) is a great technology for adding workflow functionality to any .NET application and it includes within it a very useful forward chaining rules engine.  Because the rules engine is part of WF there is an unfortunate presumption that in order to use the rules you need to be running a workflow; but who wants to do that just to run a few rules across their objects? Especially when instantiating a workflow requires quite a bit of work or using a workflow just doesn't make sense.<br />Well, as it turns out you can use the workflow rules engine on it's own without any workflows at all.  Because the windows workflow foundation architecture is very loosely coupled the workflow rules engine is effectively a standalone component that workflows call out to when they have rules to evaluate.  We can take advantage of this from our own .NET applications and call the rules engine whenever we want a set of rules evaluated against one of our objects.<br />Why would we even want to do this?<br /><ol><li><strong><em>Flexibility.</em></strong><br />Why hard code business rules into your application?  Every time a rules changes you need to recompile and redeploy your code.  Wouldn't it be great to have all these rules available as configuration data so that all that is required to change something is to edit the rule definitions - no recompilation and no redeployment.</li><li><strong><em>Ownership.</em></strong>When rules have to be hard coded into the application they become the property of the developers.  If the rules exist as configuration data and can be modified by business people then the rules can be owned and managed by those same people, not the developers.  </li><li><strong><em>Transparency.</em></strong>What happens when a rule isn't defined correctly or information isn't processed as expected?  Normally a developer has to jump into the debugger, step through the code, find the right part of the code and check what's going on.  Externalizing the rules makes it easy for non-developers to examine the rules are and see where the problem is occurring.  </li><li><strong><em>Power.</em></strong><br />It's easy enough to represent simple rules in code using if-then-else syntax, but if you've ever tried working through rule priorities or forward-chaining of rules (where one rule down the chain means a previously evaluated rule needs to be re-processed) then you know it's not an easy thing to do.  The maintenance headache it represents can be daunting.  By using a rules engine it becomes much easier to represent collections of rules that would be very difficult to implement in code.</li></ol>O.K. so if you're still with me then you're probably wanting to know how it all works.<br /><h4>Step 1:  Create A Way to Enter Rules</h4>To start with, we need some way to enter rules and somewhere to store them.  And, like all good developers, we don't want to reinvent the wheel. Go to the <a href="http://msdn.microsoft.com/">MSDN</a> web site; specifically the <a href="http://msdn.microsoft.com/en-us/library/bb472424(v=VS.90).aspx">rules engine code sample</a> and once there download and install the <a href="http://go.microsoft.com/fwlink/?LinkId=87352">ExternalRuleSetDemo</a> sample.<br />The demo shows you how to create and edit sets of rules and store them in a database.  Normally the rules editor is only available from within Visual Studio as part of the workflow editor but the ExternalRuleSetDemo shows how you can host the RuleSet Editor in a standard windows application and provide a backing store for the rules using an SqlExpress database.<br />The solution in the sample kit contains 4 projects but you really only need to look at the ExternalRuleSetLibrary project and the RuleSetTool project.<br />By the way, you don't have to use SqlExpress as the backing store.  It's a fairly trivial process to switch it to another provider.  Just go to the SaveToDB() and GetRuleSets() methods in RuleSetEditor.cs and change the code.  For fun, I switched to an SqlCe Database with very little effort.<br />Once you've compiled the application, run it and you should see something like this (but without any Rule Sets)<br /><a href="http://www.flickr.com/photos/83433068@N00/1243419651/" title="wfrules1"><img alt="wfrules1" border="0" src="http://static.flickr.com/1166/1243419651_085aa186ac.jpg" /></a><br />To create a rule set, click the New button.  A new ruleset will be created with some default information.  You can then indicate what class to base your rules on by clicking the browse button, locating the assembly that contains the class and clicking OK.<br />Next you can click the Edit Rules button to start the standard WF rules editor window as shown here:<br /><a href="http://www.flickr.com/photos/83433068@N00/1243465493/" title="wfrules2"><img alt="wfrules2" border="0" src="http://static.flickr.com/1017/1243465493_3743f0204c.jpg" /></a><br />Now you just need to create the rules you need and you should be ready to move to the next step (don't forget to save your rules!).  There is one thing to note; you can create rules using any of the properties and methods of the target class - i.e. public, internal and private properties and methods.  If you will be calling the rules engine from an assembly different to the business class then you will need to restrict the yourself to the public properties and methods or you will get runtime access permission errors.<br /><h4>Step 2: Calling the Rules Engine</h4>Ok, so now we have a way to create and edit rules.  That's great, but pretty much useless unless we have an application in which to use those rules.<br />Thankfully, the task of talking to the rules engine is actually fairly simple.  What we need to do is create a helper class that will:<br /><ul><li>Retrieve (and deserialize) the rules from the database.  </li><li>Validate the rules against the class we want to run them against  </li><li>Execute them against the object we choose.</li></ul>And then we'll use that helper class to run the rules for our business object.<br />If you go to the <a href="http://wf.netfx3.com/files/folders/rules_samples/default.aspx">samples site</a> again you can download the <a href="http://wf.netfx3.com/files/folders/rules_samples/entry819.aspx">RulesDrivenUI</a> sample and have a look at the code in there.  It's the basis for what's shown here.<br />Now, lets load up the rule set.  We'll pass in a string containing the name of the rule set we want to load and then load it up from the database.<br /><pre class="codeblock"><span style="color: blue;">public</span> <span style="color: blue;">void</span> LoadRuleSet(<span style="color: blue;">string</span> ruleSetName)<br />       {<br />           <span style="color: #2b91af;">WorkflowMarkupSerializer</span> serializer = <span style="color: blue;">new</span> <span style="color: #2b91af;">WorkflowMarkupSerializer</span>();<br />           <span style="color: blue;">if</span> (<span style="color: blue;">string</span>.IsNullOrEmpty(ruleSetName))<br />               <span style="color: blue;">throw</span> <span style="color: blue;">new</span> <span style="color: #2b91af;">Exception</span>(<span style="color: #a31515;">"Ruleset name cannot be null or empty."</span>);<br />           <span style="color: blue;">if</span> (!<span style="color: blue;">string</span>.Equals(RuleSetName, ruleSetName))<br />           {<br />               _ruleSetName = ruleSetName;<br /><br />               <span style="background-color: #eeeeaa;">ruleSet = GetRuleSetFromDB(serializer);</span><br />               <span style="color: blue;">if</span> (ruleSet == <span style="color: blue;">null</span>)<br />               {<br />                   <span style="color: blue;">throw</span> <span style="color: blue;">new</span> <span style="color: #2b91af;">Exception</span>(<span style="color: #a31515;">"RuleSet could not be loaded. Make sure the connection string and ruleset name are correct."</span>);<br />               }<br />           }<br />       }</pre><br />The <a href="http://msdn2.microsoft.com/en-us/library/system.workflow.componentmodel.serialization.workflowmarkupserializer.aspx">WorkflowMarkupSerializer</a> is used to deserialise the XML based workflow that we stored in the database (in step 1).  P.S. These methods exist in a helper class, and the ruleSet variable is a private field of the <a href="http://msdn2.microsoft.com/en-us/library/system.workflow.activities.rules.ruleset.aspx">RuleSet</a> type.<br /><br />GetRuleSetFromDB is shown below and once again it's pretty simple.  The code show here uses the SqlCe database provider, just to prove it can be done.  You can, of course, use any database mechanism you like.<br /><pre class="codeblock"><span style="color: blue;">private</span> <span style="color: #2b91af;">RuleSet</span> GetRuleSetFromDB(<span style="color: #2b91af;">WorkflowMarkupSerializer</span> serializer)<br />       {<br />           <span style="color: blue;">if</span> (<span style="color: blue;">string</span>.IsNullOrEmpty(_connectionString))<br />               <span style="color: blue;">return</span> <span style="color: blue;">null</span>;<br />           <span style="color: #2b91af;">SqlCeDataReader</span> reader;<br />           <span style="color: #2b91af;">SqlCeConnection</span> sqlConn = <span style="color: blue;">null</span>;<br />           <span style="color: blue;">try</span>            {<br />               sqlConn = <span style="color: blue;">new</span> <span style="color: #2b91af;">SqlCeConnection</span>(_connectionString);<br />               sqlConn.Open();<br />               <span style="color: #2b91af;">SqlCeParameter</span> p1 = <span style="color: blue;">new</span> <span style="color: #2b91af;">SqlCeParameter</span>(<span style="color: #a31515;">"@p1"</span>,_ruleSetName);<br />               <span style="color: blue;">string</span> commandString = <span style="color: #a31515;">"SELECT * FROM RuleSet WHERE Name= @p1 ORDER BY ModifiedDate DESC"</span>;<br />               <span style="color: #2b91af;">SqlCeCommand</span> command = <span style="color: blue;">new</span> <span style="color: #2b91af;">SqlCeCommand</span>(commandString, sqlConn);<br />               command.Parameters.Add(p1);<br />               reader = command.ExecuteReader();<br />           }<br />           <span style="color: blue;">catch</span> (<span style="color: #2b91af;">Exception</span> e)<br />           {<br />               ...<br />           }<br />           <span style="color: #2b91af;">RuleSet</span> resultRuleSet = <span style="color: blue;">null</span>;<br /><br />           <span style="color: blue;">try</span>            {<br />               reader.Read();<br />                <span style="background-color: #eeeeaa;">resultRuleSet = DeserializeRuleSet(reader.GetString(3), serializer);</span><br />            }<br />           <span style="color: blue;">catch</span>            {<br />               <span style="color: #2b91af;">...</span><br />           }<br />           sqlConn.Close();<br />           sqlConn.Dispose();<br />           <span style="color: blue;">return</span> resultRuleSet;<br />       }</pre><br />Note the call to DeserializeRuleSet() [in bold].  This is where the ruleset we retrieved from the database is converted from XML back to a ruleset object.  It basically wraps a call to the WorkflowMarkupSerializer as shown:<br /><pre class="codeblock"><span style="color: #2b91af;">StringReader</span> stringReader = <span style="color: blue;">new</span> <span style="color: #2b91af;">StringReader</span>(ruleSetXmlDefinition);<br />               <span style="color: #2b91af;">XmlTextReader</span> reader = <span style="color: blue;">new</span> <span style="color: #2b91af;">XmlTextReader</span>(stringReader);<br />               <span style="color: blue;">return</span> serializer.Deserialize(reader) <span style="color: blue;">as</span> <span style="color: #2b91af;">RuleSet</span>;</pre><br />Cool!  So now we've got the rules loaded up from the database.<br /><br />At this point we'd love to be able to just point the rules at an object of our choice and run them, but before we do, we have to check that the rules are still valid.  Why?  Because when we deserialised the rules from the database we had no guarantee that those rules were still valid for the object we are going to run them against.  Method signatures may have changed, properties may have been removed or we may have loaded up rules created for a completely different class.  By validating the rules we protect ourselves from (most) run time errors.<br /><br />To do it we use the <a href="http://msdn2.microsoft.com/en-us/library/system.workflow.activities.rules.rulevalidation.aspx">RuleValidation</a> class.  We also use the <a href="http://msdn2.microsoft.com/en-us/library/system.workflow.activities.rules.ruleexecution.aspx">RuleExecution</a> class to get an execution context:<br /><pre class="codeblock"><span style="color: blue;">private</span> <span style="color: #2b91af;">RuleExecution</span> ValidateRuleSet(<span style="color: blue;">object</span> targetObject)<br />       {<br />           <span style="color: #2b91af;">RuleValidation</span> ruleValidation;<br /><br />            <span style="background-color: #eeeeaa;">ruleValidation = <span style="color: blue;">new</span> <span style="color: #2b91af;">RuleValidation</span>(_targetType, <span style="color: blue;">null</span>);</span><br />            <span style="color: blue;">if</span> (!ruleSet.Validate(ruleValidation))<br />           {<br />               <span style="color: blue;">string</span> errors = <span style="color: #a31515;">""</span>;<br />               <span style="color: blue;">foreach</span> (<span style="color: #2b91af;">ValidationError</span> validationError <span style="color: blue;">in</span> ruleValidation.Errors)<br />                   errors = errors + validationError.ErrorText + <span style="color: #a31515;">"\n"</span>;<br />               <span style="color: #2b91af;">Debug</span>.WriteLine(<span style="color: #a31515;">"Validation Errors \n"</span> + errors);<br />               <span style="color: blue;">return</span> <span style="color: blue;">null</span>;<br />           }<br />           <span style="color: blue;">else</span>            {<br />                <span style="background-color: #eeeeaa;"><span style="color: blue;">return</span> <span style="color: blue;">new</span> <span style="color: #2b91af;">RuleExecution</span>(ruleValidation, targetObject);</span><br />            }<br />       }</pre><br />There are 2 important things happening here.  Firstly we are validating the rules by passing in the type of the object we are going to run them against and checking if there are any errors.  Then secondly we are creating an instance of the RuleExecution class.  This is needed to store the state information used by the rule engine when validating rules.  Note that while we are passing in the validated rules and the object we want to execute the rules on at this  point we have not yet executed the rules, we have just created the context in which they will run.<br /><br />So now we come to it. Finally! It's a really simple call to the RuleSet <a href="http://msdn2.microsoft.com/en-us/library/system.workflow.activities.rules.ruleset.execute.aspx">Execute</a> method:<br /><pre class="codeblock"><span style="color: blue;">private</span> <span style="color: blue;">void</span> ExecuteRule(<span style="color: #2b91af;">RuleExecution</span> ruleExecution)<br />       {<br />           <span style="color: blue;">if</span> (<span style="color: blue;">null</span> != ruleExecution)<br />           {<br />               ruleSet.Execute(ruleExecution);<br />           }<br />           <span style="color: blue;">else</span>            {<br />               <span style="color: blue;">throw</span> <span style="color: blue;">new</span> <span style="color: #2b91af;">Exception</span>(<span style="color: #a31515;">"RuleExecution is null."</span>);<br />           }<br />       }</pre><br />We can now wrap all these methods up into a simple method as follows:<br /><pre class="codeblock"><span style="color: blue;">public</span> <span style="color: blue;">void</span> ExecuteRuleSet(<span style="color: blue;">object</span> targetObject)<br />       {<br />           <span style="color: blue;">if</span> (ruleSet != <span style="color: blue;">null</span>)<br />           {<br />               <span style="color: #2b91af;">RuleExecution</span> ruleExecution;<br />               ruleExecution = ValidateRuleSet(targetObject);<br />               ExecuteRule(ruleExecution);<br />           }<br />       }</pre><br /><br />Now to run rules for our class all we need to do is make two simple calls.  Assuming we have put the above code in a helper class then we can do something like this:<br /><pre class="codeblock"><span style="color: #2b91af;">WorkflowRulesHelper</span> wfhelper = <span style="color: blue;">new</span> <span style="color: #2b91af;">WorkflowRulesHelper</span>();<br />           wfhelper.LoadRuleSet(<span style="color: #a31515;">"LSCRules"</span>);<br />           wfhelper.ExecuteRuleSet(<span style="color: blue;">this</span>);</pre><a href="http://11011.net/software/vspaste"></a><br />Now all we need to run rules in our classes is these few lines of code.<br /><br />Pretty cool, hey?  If you've got any comments I'd love to hear them :-)