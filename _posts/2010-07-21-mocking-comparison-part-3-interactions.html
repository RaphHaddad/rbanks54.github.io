---
layout: post
title: 'Mocking Comparison – Part 3: Interactions'
date: '2010-07-21T21:37:00.001+10:00'
author: Richard Banks
tags:
- mocking
modified_time: '2010-08-06T08:54:27.450+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-2640679655088288230
blogger_orig_url: http://www.richard-banks.org/2010/07/mocking-comparison-part-3-interactions.html
---

<p>Our comparison of Rhino Mocks, Moq and NSubstitute continues with a look at how these frameworks support interaction based testing (whether that’s a good idea or not is not going to be dealt with here!).</p>  <p>The idea behind interaction based testing is checking if our class under test makes appropriate calls to the mocked objects.&#160; Typically this is done when testing against API’s that want things done in a certain order or where you want to check that the Save method of a repository was called, as an example.</p>  <p>For our example code we’re going to be testing that the Keeper makes the appropriate call to check the current flea count and then, because the flea count is low, does not try and clean the monkey, i.e. Monkey.Clean() should not be called.</p>  <p>Note that code for the classes under test is in <a title="Mocking Comparison - Part 1" href="http://www.richard-banks.org/2010/07/mocking-comparison-part-1-basics.html" target="_blank">Part 1</a> of this series.</p>  <h3>Rhino Mocks</h3>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:b83a9ae1-110c-4885-ae88-7964d842fadc" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Rhino_method_was_called()<br />{<br /> var monkey = MockRepository.GenerateMock&lt;IMonkey&gt;();<br /> var keeper = new ZooKeeper {AssignedMonkey = monkey};<br /> monkey.Stub(m =&gt; m.CurrentFleaCount()).Return(0);<br /><br /> keeper.CleanMonkey();<br /><br /> monkey.AssertWasCalled(m =&gt; m.CurrentFleaCount());<br /> monkey.AssertWasNotCalled(m =&gt; m.Clean());<br />}</pre></div><p>So in the initial arrange section of our test we stub out the CurrentFleaCount() call to return zero fleas when called.</p><p>We then perform the Act part of our test and ask the Keeper to clean the monkey.</p><p>Finally in the Assert part of our test we check if the monkey had methods called on it – the CurrentFleaCount method should be called, and the Clean method should not be called.</p><p>If you’re playing along at home, you may have noticed that changing the monkey’s flea count to 100 still makes the test pass, when we should have expected the test to fail (because the clean method should now be called).&#160; This won’t happen because there is a second guard clause in the keeper’s CleanMonkey() method that checks if the monkey is awake and this will always return false.</p><p>It brings up an important point with all mock objects in that the default response for any method not explicitly stubbed out is to return the default value, and the default for a bool is false.</p><h3>Moq</h3><div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:a2ae7fa2-a888-4eac-82a1-84b07377c0e5" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Moq_method_was_called()<br />{<br /> var monkey = new Mock&lt;IMonkey&gt;();<br /> var keeper = new ZooKeeper() {AssignedMonkey = monkey.Object};<br /><br /> monkey.Setup(m =&gt; m.CurrentFleaCount()).Returns(0);<br /><br /> keeper.CleanMonkey();<br /><br /> monkey.Verify(m =&gt; m.CurrentFleaCount());<br /> monkey.Verify(m =&gt; m.Clean(), Times.Never());<br />}</pre></div><p>  <p>The code here is similar to Rhino’s code however you’ll notice that to configure our mock object in Moq we use Setup instead of Stub/Expect calls to set the return behaviour for the flea count method.</p>  <p>Moq uses a single Verify method to check that a call was made, so to check that something wasn’t called you have to check that it was called zero times – expressed in Moq syntax as Times.Never().&#160; Make your own mind up over whether this is clear enough from a readability perspective, but I find that it feels a little like Yoda has been writing code and the Verify call seems like it should have a boolean statement for its parameter, not be asserting that a method was called.</p>  <h3>NSubstitute</h3>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:314e58f2-06e8-4bc1-bab2-bfbaa827cfee" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Nsubstitute_method_was_called()<br />{<br /> var monkey = Substitute.For&lt;IMonkey&gt;();<br /> var keeper = new ZooKeeper { AssignedMonkey = monkey };<br /> monkey.CurrentFleaCount().Returns(0);<br /><br /> keeper.CleanMonkey();<br /><br /> monkey.Received().CurrentFleaCount();<br /> monkey.DidNotReceive().Clean();<br />}</pre></div>  <p>Firstly, not the lack of lambda methods anywhere in this code.&#160; The mock object behaviour is setup by simply attaching a .Returns(0) to the monkey.CurrentFleaCount() method making the code more expressive and simpler to read.</p>  <p>As far as the asserts are concerned we check that a call was Received() by our mock object or that the mock DidNotReceive() the call.&#160; I find this syntax better than the other frameworks in that there’s no lambdas, but it doesn’t read quite as well as I might like.</p>  <p>&#160;</p>  <p>The verdict: It’s a split decision between Rhino and NSubstitute, with me wanting the best of both.</p></p><p>&nbsp;</p><p>Other posts in this series:<ul><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-1-basics.html">1: The Basics</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-2-properties.html">2: Properties</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-4-parameter.html">4: Parameter Constraints</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-5-repetitions.html">5: Repetitions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-6-multiple.html">6: Multiple Calls</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-7-exceptions.html">7: Exceptions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-8-recursive.html">8: Recursive Mocks</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-9-functions.html">9: Functions</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-10-events.html">10: Events</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-11-multiple.html">11: Multiple Interfaces</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-12-unmockables.html">12: The UnMockables</a></li></ul></p>