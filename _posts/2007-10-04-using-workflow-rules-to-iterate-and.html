---
layout: post
title: Using Workflow Rules to Iterate and Remove Items From a Collection
date: '2007-10-04T18:13:00.001+10:00'
author: Richard Banks
tags:
- readify
- ".net"
- workflow
- development
modified_time: '2007-10-04T18:13:56.574+10:00'
thumbnail: http://lh3.google.com/rbanks54/RwSgw5-HM7I/AAAAAAAAAKQ/CZJbTscfUZ0/s72-c/image_thumb1.png
blogger_id: tag:blogger.com,1999:blog-13321238.post-1260572187784544631
blogger_orig_url: http://www.richard-banks.org/2007/10/using-workflow-rules-to-iterate-and.html
---

<p>I got asked recently if it was possible to use the Workflow Rules engine to remove items from a collection.</p> <p>It turns out that it's actually quite easy to do, as long as you understand how the rules engine works, and how to iterate over collections.&nbsp; So before I show you how to remove items from a collection, let's run through how you can use a rule set to iterate through a collection.</p> <p>Oh, before we go any further, this blog post is based on the "RulesWithCollectionSample" that you can get from the <a href="http://wf.netfx3.com">netfx3</a> site.</p> <p>So if you haven't already done so, go to the site, download the sample and make sure everything compiles and runs properly. P.S. make sure you have the ExternalRuleSetToolkit sample from the site as well since the RulesWithCollections.rules file that comes with the sample need to be imported into the database using the ExternalRuleSetToolkit.</p> <p>What you should see when you run the sample is a screen that looks like the following:</p> <p><a href="http://lh4.google.com/rbanks54/RwSgwJ-HM6I/AAAAAAAAAKI/xxDtTdah6qs/image3.png"><img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" height="527" alt="image" src="http://lh3.google.com/rbanks54/RwSgw5-HM7I/AAAAAAAAAKQ/CZJbTscfUZ0/image_thumb1.png" width="509" border="0"></a> </p> <p>When you click on the "Calculate on Object Collection" the workflow rules engine is invoked, calculates the sum of the individual items in the collection and displays the result next to the button.</p> <p>The question is how?</p> <h4>Understanding Rule Chaining</h4> <p>The key to this sample is an understanding of how the rules engine works.&nbsp; The rules engine is a forward chaining rules engine, which in simple terms means that if a rule relies on a property in it's evaluation and a subsequent rule changes the value of that property then the rule will be reevaluated as well as any subsequent rules in the chain.</p> <p>What this means is that if we have 2 rules defined as follows:</p> <p>1) if Customer.Priority = 2 then CallCentre.StaffType="Manager" else CallCentre.StaffType="Normal"</p> <p>2) if Customer.Name = "Special Customer" then Customer.Priority=2</p> <p>And if the customer in question is a "Special Customer" with a priority of 0 then what will happen is the following:</p> <p>i) The Condition clause for Rule 1 will get evaluated.&nbsp; Because Customer.Priority is part of the condition (ie the rule depends on that value) then the Customer.Priority property will be tracked by the rules engine.&nbsp; Conversely, the CallCentre.StaffType is not part of the rule condition and is therefore not tracked by the rules engine.</p> <p>ii) Because the customer has a priority of 0 the CallCentre,StaffType is assigned to "Normal".</p> <p>iii) Rule 2 is evaluated and since the Customer.Name matches the condition the Customer.Priority value is changed to 2.</p> <p>iv) Here's where the magic happens.&nbsp; The rules engine detects that the Customer.Priority value has changed and that Rule 1 (which is higher in the rule chain) depended on that value in it's evaluation.&nbsp; The rules engine stops processing any further rules, goes back to Rule 1 and re-executes it, resulting in the CallCentre.StaffType value being changed to "Manager".</p> <p>And before you ask, yes - it's entirely possible to set up an infinite loop in your rules when chaining is being used.</p> <p>For this reason and because you don't always want the chaining to happen it is possible to change the default chaining behavior of a rule set.</p> <h4>Iterating Collections</h4> <p>OK, now to the sample code.</p> <p>As shown above the sample has a list of numbers in the list box.&nbsp; When you click on the "Calculate On Object Collection" button an Order object is created that contains a collection of OrderItem objects.&nbsp; Each OrderItem in the collection has a price based on the corresponding list entry.</p> <p>The workflow rules engine is then invoked on the Order object using the OrderRuleSet which in turn iterates over the elements in the collection and calculate the sum of the OrderItems giving a total order value.</p> <p>Now, unless you were particularly into self-harm this is not something you would normally do via the rules engine but it does show you the principle involved in collection iteration.</p> <p>Let's have a look at the ruleset.&nbsp; You should see that there are 4 rules all at different priority levels.&nbsp; The first rule to be executed is the one with the highest priority (larger numbers are higher priorities) - the Initialize rule.</p> <p>The Initialize rule merely obtains the enumerator for the OrderItems collection and assigns it to the Order.enumerator property.</p><pre class="codeblock"><p>Rule: Initialize</p><br /><p>Condition: 1 == 1</p><br /><p>Then: this.enumerator = this.OrderItems.GetEnumerator()<br>      System.Console.WriteLine("Initializing")</p><br /><p>Else: ---</p></pre><br /><p>What's with that 1 == 1 business?&nbsp; Well, all it does is force the Condition to evaluate to tru.&nbsp; My personal preference if you want to use something to always evaluate to true is to use "true".&nbsp; Using 1 == 1 just feels wierd.</p><br /><p>The next rule, IteratorOverItems, performs a MoveNext using the iterator we obtained in the inialise shed.&nbsp; MoveNext will return true until it reaches the end of the collection.</p><pre class="codeblock"><p>Rule: IteratorOverItems</p><br /><p>Condition: this.enumerator.MoveNext()</p><br /><p>Then: this.CurrentItem = (RulesWithCollectionSample.OrderItem)this.enumerator.Current<br>      System.Console.WriteLine("Assignedenumerator" + this.OrderItems[0].Price)</p><br /><p>Else: System.Console.WriteLine("we are all done") </p></pre><br /><p>If MoveNext didn't fall off the end of the collection, we take the current item from the iterator and assign it to the Order.CurrentItem property.&nbsp; We could reference the value from enumerator.Current in later stages, but by placing the value in a specific property we make it easier for the rules engine to know when the value changes.</p><br /><p>The next rule is the IndividualItem rule</p><pre class="codeblock"><p>Rule: IndividualItem</p><br /><p>Condition: this.CurrentItem != null</p><br /><p>Then: this.Total = this.Total + this.CurrentItem.Price * this.CurrentItem.Quantity<br>      System.Console.WriteLine("Running Total: " + this.Total.ToString())</p><br /><p>Else: System.Console.WriteLine("current item is null")</p></pre><br /><p>So, we check if the Current OrderItem the iterator gave us still references a real, live, breathing object and if it does we add the OrderItem total cost onto the Order object's Total.</p><br /><p>So, that's it.&nbsp; 3 simple rules and we're done.</p><br /><p>Well not quite.&nbsp; If we ran this rule set now, we would only ever get the total using the first OrderItem in the collection.</p><br /><p>We need some way to cause the enumerator.MoveNext() method to get reevaluated so we can get the next OrderItem from the collection, but the only way a rule gets re-evaluated is when the objects used in the Condition change.&nbsp; We don't want to change the iterator itself, we just want to call MoveNext() again.</p><br /><h4>Explicit Chaining</h4><br /><p>This is where the final rule kicks in.</p><pre class="codeblock"><p>Rule: FInished</p><br /><p>Condition: this.CurrentItem == this.CurrentItem</p><br /><p>Then: System.Console.WriteLine("Finished True")<br>      Update("this/enumerator")</p><br /><p>Else: System.Console.WriteLine("Finished False")<br>      Update("this/enumerator")</p></pre><br /><p>First up we check this.CurrentItem against itself.&nbsp; It should always return True, so the Then action in the rule will get evaluated.</p><br /><p>In here you'll notice the use of the Update method.</p><br /><p>The Update method is part of the rules engine and tells the engine that a property (or properties) has been changed and any rules that depend on that property should be re-evaluated.&nbsp; You don't actually have to change the value of the property itself, you're just telling the rules engine to act as if the value changed.</p><br /><p>The IteratorOverItems rule uses the this.enumerator property in it's condition.&nbsp; Updating the enumerator will cause the rule to be reevaluated, causing MoveNext() to be called, which in turn updates the CurrentItem property, causing the IndividualItem property to be reevaluated and thus incrementing the Order.Total property to give us our total.</p><br /><p>After seeing this there's a few questions you might ask:</p><br /><p><em>What's up with that weird slash notation in the Update statement?</em> Think of it like a path to a property.&nbsp; In this case there is only one property, but the Update statement allows you to mark multiple properties as updated using wildcards. e.g Update("this/*").&nbsp; If you want to use dot notation that's fine as well.&nbsp; Just use Update(this.enumerator) - no quotes.</p><br /><p><em>Why does the Condition use this.CurrentItem and not just use True?</em>&nbsp; Simple.&nbsp; Once a rule is evaluated it is marked as done.&nbsp; It will only ever get reevaluated if the properties in it's condition clause are updated.&nbsp; The value "True" is a constant so the rule would never get re-evaluated.&nbsp; By using this.CurrentItem, every time the current item changes this rule gets evaluated again.</p><br /><p>&nbsp;</p><br /><p>So, now we have a pattern to how to iterate collections:</p><br /><p><font color="#000080">1. Get the enumerator</font></p><br /><p><font color="#000080">2. Use MoveNext and get the Current element of the collection</font></p><br /><p><font color="#000080">3. Do something with that current item (ie your business rules, etc).&nbsp; Make sure the Current Item is used in the Condition so the the rule is reevaluated for each item</font></p><br /><p><font color="#000080">4. Call Update() on the enumerator to force re-evaluation of the IteratorOverItems rule and ensure that this rule uses CurrentItem in the condition.</font></p><br /><p>&nbsp;</p><br /><h4>Deleting Items In A Collection</h4><br /><p>Phew! Now that we know how to iterate over a collection how about we try and delete something from it.&nbsp; Let's try removing every OrderItem with a price greater than 20?</p><br /><p>It's pretty much the same as iterating the collection, but the thing to watch for is that when you delete an element from a collection you invalidate the enumerator and have to get a fresh one.&nbsp; We'll need some way to force the enumerator to get refreshed.</p><pre class="codeblock"><p>Rule: Initialise (priority 2)</p><br /><p>Condition: this.ID == this.ID</p><br /><p>Then: this.enumerator = this.OrderItems.GetEnumerator()<br>      System.Console.WriteLine("Got the enumerator")</p><br /><p>Else: System.Console.WriteLine("Didnt get the enumerator")</p></pre><br /><p>Note the difference here.&nbsp; The condition is no longer 1 == 1 (or True).&nbsp; Why, because we're going to Update() the ID property after we delete an element to force the rule to re-evaluate, in turn refreshing our enumerator.</p><pre class="codeblock"><p>Rule: Iterate (priority 1)</p><br /><p>Condition: this.enumerator.MoveNext()</p><br /><p>Then: this.CurrentItem = (RulesWithCollectionSample.OrderItem)this.enumerator.Current<br>      System.Console.WriteLine("Got an item")</p><br /><p>Else: System.Console.WriteLine("No more items") </p></pre><br /><p>This is the same as the previous Iterate rule.&nbsp; Nothing different at all <pre class="codeblock"><p>Rule: IndividualItem (Priority 0) <p><br /><p>Condition: this.CurrentItem != null &amp;&amp; this.CurrentItem.Price &gt; 20 <p><br /><p>Then: System.Console.WriteLine("Got an item over 20")<br>      System.Console.WriteLine("About to remove an item")<br>      this.OrderItems.Remove(this.CurrentItem)<br>      Update("this/ID")</p><br /><p>Else: System.Console.WriteLine("Got an item under 20")<br>      Update("this/enumerator") </p></pre><br /><p>Ok, here's where the action is.&nbsp; In the Condition we check the CurrentItem for null and then check it's price.&nbsp; If the item is null or the price is under 21 then we'll execute the Else actions. <br /><p>The Else action just calls Update() on the enumerator - just like in the collection iteration ruleset above. <br /><p>But what happens when the price is over 20? <br /><p>First we remove the item from the collection using the normal .NET Remove method. <br /><p>We then mark the ID field of the Order object as updated using the Update() statement.&nbsp; This causes the Initialise rule to get reevaluated, which results in restarting our collection processing all over again.<br /><p>If we were to just Update() the enumerator using Update(this.enumerator) instead, we would get a run time error when MoveNext() is called since the collection has been changed.&nbsp; Forcing the Initialise rule to get reprocessed ensures that we get a fresh enumerator for the collection and avoids the run time errors.</p> 