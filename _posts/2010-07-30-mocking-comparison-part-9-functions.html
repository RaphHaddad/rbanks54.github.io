---
layout: post
title: 'Mocking Comparison – Part 9: Functions'
date: '2010-07-30T20:19:00.001+10:00'
author: Richard Banks
tags:
- mocking
modified_time: '2010-08-06T08:56:44.800+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-5747032922892135801
blogger_orig_url: http://www.richard-banks.org/2010/07/mocking-comparison-part-9-functions.html
---

<p>Let’s say you’ve got a mock object and you want a method on your mock to do something with a particular method that goes beyond just returning a specified value.&#160; What do you do?&#160; Why, you use a function of course!&#160; When you stub a method call on a mock you simply tell the mock object to call a method or use a lambda to calculate the return value rather than just returning a specified value.</p>  <p>Let’s have a look at how Rhino Mocks, Moq and NSubstitute do this.</p>  <p>What we’re going to do is supply some simple methods that our mock object will use when we call certain methods so that we can dynamically alter the return value from the CurrentFleaCount method and we’ll then assert that the value has changed.</p>  <h3>Rhino Mocks</h3>  <p></p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:8e2b0f69-5b43-49dc-ae27-3e2666993e7d" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Rhino_functions_and_callbacks()<br />{<br /> var fleaCount = 25;<br /> var monkey = MockRepository.GenerateMock&lt;IMonkey&gt;();<br /><br /> monkey.Stub(m =&gt; m.CurrentFleaCount()).Do(new Func&lt;int&gt;(() =&gt; fleaCount));<br /> monkey.Stub(m =&gt; m.TryAddFleas(1)).IgnoreArguments()<br />  .Do(new Func&lt;int, bool&gt;(fleas =&gt;<br />  {<br />   fleaCount = fleas;<br />   return true;<br />  }));<br /><br /> Assert.Equal(25, monkey.CurrentFleaCount());<br /><br /> monkey.TryAddFleas(10);<br /> Assert.Equal(10, monkey.CurrentFleaCount());<br />}</pre></div><p>Since this is a reasonable chunk of code, let’s just look at the key parts.&#160; When we stub the CurrentFleaCount method call we tell it to use a function that takes no arguments, and use the value of the fleaCount variable (defined in the test) to figure out what returns.</p><p>You may ask why didn’t we just do a .Return(fleaCount) like we normally would? Simple answer: we want to get the value to change as the test progresses.&#160; By using a Func&lt;T&gt; means that the return value is calculated each time we call the stubbed method, rather than just having a single fixed value returned for every call.</p><p>Similarly in the stubbed TryAddFleas() method, we are providing a function that takes one parameter and returns a boolean.&#160; Our stub method simply changes the value of fleaCount variable so that the next CurrentFleaCount() call will return a different value, and this is what the Asserts are checking for.</p><p>Hopefully that makes sense.&#160; Form a day to day usage viewpoint it’s not something you do that often but when you need the functionality it’s really useful.</p><h3>Moq</h3><div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:c1d2ac43-30f1-4a19-bdd6-ed906142b2bc" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Moq_functions_and_callbacks()<br />{<br /> var fleaCount = 25;<br /> var monkey = new Mock&lt;IMonkey&gt;();<br /> <br /> monkey.Setup(m =&gt; m.CurrentFleaCount()).Returns(() =&gt; fleaCount);<br /> monkey.Setup(m =&gt; m.TryAddFleas(It.IsAny&lt;int&gt;()))<br />  .Returns&lt;int&gt;(fleas =&gt;<br />  {<br />   fleaCount = fleas;<br />   return true;<br />  });<br /><br /> Assert.Equal(25, monkey.Object.CurrentFleaCount());<br /><br /> monkey.Object.TryAddFleas(10);<br /> Assert.Equal(10, monkey.Object.CurrentFleaCount());<br />}</pre></div><p>The Moq syntax is much the same as the Rhino syntax, as you can see.&#160; It’s probably a little nicer in that you use the same Returns() method to either return fixed values or call a function, unlike Rhino Mocks where you have to use the .Do() method.</p><p>It also doesn’t require the creation of new Func&lt;T&gt; objects – you just supply the method body you wish to use, which means less code.</p><h3>NSubstitute</h3><div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:189b0f9d-7caf-4fee-abda-950c393728a6" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Nsubstitute_functions_and_callbacks()<br />{<br /> var fleaCount = 25;<br /> var monkey = Substitute.For&lt;IMonkey&gt;();<br /><br /> monkey.CurrentFleaCount().Returns(args =&gt; fleaCount);<br /> monkey.TryAddFleas(Arg.Any&lt;int&gt;())<br />  .Returns(args =&gt;<br />  {<br />      fleaCount = (int)args[0];<br />      return true;<br />  });<br /><br /> Assert.Equal(25, monkey.CurrentFleaCount());<br /><br /> monkey.TryAddFleas(10);<br /> Assert.Equal(10, monkey.CurrentFleaCount());<br />}</pre></div><p>The NSubstitute code is a little different to the others in that instead of having parameter lists to deal with you are passed a single array containing all the parameters and it’s up to you to pull out the ones you wish to use and cast them as required by your test.</p><p>This has it’s advantages in that you avoid code littered with arguments you never use, but it has a downside in that you need to cast every parameter you do use.&#160; That said, just like Moq, you get to use the same Returns() method for either returning a fixed value or supplying a method and you don’t need to create new Func&lt;T&gt; objects so the code isn’t noisy.&#160; And better than Moq is it’s overall cleaner syntax, as we have seen in many of the previous posts.</p><p>My preference? NSubstitute.&#160; The casting of parameters is a little annoying, but it doesn’t have Moq .Object. tax and this is one of the few times you’ll actually see a lambda in a test using NSubstitute.</p><p>&nbsp;</p><p>Other posts in this series:<ul><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-1-basics.html">1: The Basics</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-2-properties.html">2: Properties</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-3-interactions.html">3: Interactions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-4-parameter.html">4: Parameter Constraints</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-5-repetitions.html">5: Repetitions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-6-multiple.html">6: Multiple Calls</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-7-exceptions.html">7: Exceptions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-8-recursive.html">8: Recursive Mocks</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-10-events.html">10: Events</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-11-multiple.html">11: Multiple Interfaces</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-12-unmockables.html">12: The UnMockables</a></li></ul></p>