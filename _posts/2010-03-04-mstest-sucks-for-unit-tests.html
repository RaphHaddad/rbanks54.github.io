---
layout: post
title: MSTest Sucks for Unit Tests
date: '2010-03-04T14:48:00.001+11:00'
author: Richard Banks
tags: 
modified_time: '2010-03-04T14:53:38.409+11:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-6020940642935540640
blogger_orig_url: http://www.richard-banks.org/2010/03/mstest-sucks-for-unit-tests.html
---

Inflammatory title?&nbsp; Maybe. But I'm not the only person to complain that MSTest is bad and should only be used when no other alternative is available.&nbsp; But those who don’t know better will say that when you look at all the unit test frameworks they all do much the same right? So how can MSTest be that bad?<br />Well, first up, MSTest is slow. To be fair, MSTest when run from the command line runs quick. From the command line you won’t notice much difference at all between MSTest and the other unit testing frameworks, but who runs MSTest from the command line?&nbsp; Most people run it from within Visual Studio, and when you do, it is really really sow. It does all that assembly copying behind the scenes, it waits for the test results window in the IDE to update and then, finally after all that is done, only then does it run the tests. If you’re writing and running lots of unit tests (you are, aren't you?) then this startup delay is real hindrance to flow and after a while is a major pain in the butt. So much so that many people stop doing tests after they hit a few hundred or so, simply because of the time it takes to run them.<br />But if speed were the only issue, then maybe the other features would make up for it.&nbsp; After all it has those cool data driven tests right?<br />Well, lets consider an example.&nbsp; Let’s say I’m doing the <a href="http://codingdojo.org/cgi-bin/wiki.pl?KataBowling" target="_blank">bowling game kata</a> and I want to use a data driven test to check a number of scenarios.&nbsp; Here’s what I’d have to do:<br />1. Create an XML file to act as a data source<br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="utf-8" ?&gt;<br />&lt;Rows&gt;<br />&nbsp; &lt;Row&gt;<br />&nbsp;&nbsp;&nbsp; &lt;Scores&gt;0123456789X&lt;/Scores&gt;<br />&nbsp;&nbsp;&nbsp; &lt;Results&gt;0,1,2,3,4,5,6,7,8,9,10&lt;/Results&gt;<br />&nbsp; &lt;/Row&gt;<br />&nbsp; &lt;Row&gt;<br />&nbsp;&nbsp;&nbsp; &lt;Scores&gt;935345XXXX&lt;/Scores&gt;<br />&nbsp;&nbsp;&nbsp; &lt;Results&gt;9,3,5,3,4,5,10,10,10,10&lt;/Results&gt;<br />&nbsp; &lt;/Row&gt;<br />&lt;/Rows&gt;<br /></pre>2. Now create a data driven unit test using MSTest<br /><pre class="brush:csharp">[TestClass()]<br />public class ScoreEngineTest <br />{ <br />&nbsp;&nbsp;&nbsp; private TestContext testContextInstance;<br /><br />&nbsp;&nbsp;&nbsp; public TestContext TestContext <br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return testContextInstance;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; testContextInstance = value; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp; } <br /><br />[TestMethod] <br />[DeploymentItem(@"TestProject1\BowlingScores.xml")] <br />[DataSource("Microsoft.VisualStudio.TestTools.DataSource.XML", "|DataDirectory|\\BowlingScores.xml", "row", DataAccessMethod.Sequential)] <br />public void ConvertStringToScoresTest_DataDriven() <br />{ <br />&nbsp;&nbsp;&nbsp; ScoreEngine target = new ScoreEngine(); <br />&nbsp;&nbsp;&nbsp; var scores = (String)TestContext.DataRow["Scores"];<br />&nbsp;&nbsp;&nbsp; var expectedData = ((string)TestContext.DataRow["Results"]).Split(',');<br />&nbsp;&nbsp;&nbsp; var expected = new List&lt;int&gt;();<br />&nbsp;&nbsp;&nbsp; foreach (var value in expectedData)<br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expected.Add(int.Parse(value)); <br />&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp; var actual = target.ConvertScores(scores); <br />&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; expected.Count; i++)<br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (expected[i] != actual[i]) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Assert.Fail("Expected {0}, Actual {1} at element {2}", expected[i], actual[i], i); <br />&nbsp;&nbsp;&nbsp; } <br />}<br /></pre><br />Quite verbose right?&nbsp; Especially the fact that there is no inbuilt list equality checks nor is there an easy way to use list based data in the data source.&nbsp; I had to take a string, split it and manually create a list.&nbsp; Eew!<br /><br />So let’s look at the XUnit version.<br /><br /><pre class="brush:csharp">public class Class1<br />{<br />&nbsp;&nbsp;&nbsp; [Theory]<br />&nbsp;&nbsp;&nbsp; [InlineData("0123456789X", new int[]{0,1,2,3,4,5,6,7,8,9,10})]<br />&nbsp;&nbsp;&nbsp; public void ConvertStringToScoresTest(string scores, int[] results)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ScoreEngine target = new ScoreEngine();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var actual = target.ConvertScores(scores);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Assert.Equal(results,actual.ToArray());<br />&nbsp;&nbsp;&nbsp; }<br />}</pre><br /><br />Wow! So much shorter!  And so much more intuitive.  And an Assert statement that actually does equality checks across IEnumerables as you would expect.<br /><br />So maybe now you see why MSTest gets such a bollocking by so many people.<br />To be fair, MSTest is improving, and things like Test Impact Analysis in VS2010 are quite nice, but still... the amount of code to writing a simple data driven test is ridiculous and completely unnecessary.