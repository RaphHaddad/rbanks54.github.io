---
layout: post
title: 'Basics: Adding Lambda Support To Your Classes'
date: '2009-05-05T16:12:00.005+10:00'
author: Richard Banks
tags:
- ".net"
- development
- basics
modified_time: '2009-06-05T11:07:17.879+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-1246516007951140087
blogger_orig_url: http://www.richard-banks.org/2009/05/basics-adding-lambda-support-to-your.html
---

<p>I talked recently about Linq and Extension methods and showed how you could refactor For Each loops into simple linq statements.&nbsp; When using Linq one of the things you will often come across are Lambda functions (anonymous methods declared inline).</p> <p>If you’re a curious type, then you might ask yourself “How can I make it so my classes can use Lambda functions?”.&nbsp; If that’s you then read on :-)</p> <p>In this scenario I’m going to try and do a few things.&nbsp; I want to create a simple class that has a collection of strings in it and I want to have a method in that class to print those strings.&nbsp; But here’s the catch, I don’t want to actually code up that printing method itself in my class.&nbsp; It doesn’t really belong there and instead&nbsp; I want someone else to handle the printing – I just want to send them the strings in the class and let them worry about it.</p> <p>Now I could do it using Dependency Injection techniques, but that’s a different discussion.&nbsp; Here and now, I want to have someone supply me a function and I’ll just call it.</p> <h4>Test First</h4> <p>Let’s start by creating a test for it first (forgive me for not putting any asserts in the code).&nbsp; Here’s what it looks like</p><pre class="brush:csharp">[TestMethod]<br />public void TestMethod()<br />{<br />    StringHolder stringHolder = new StringHolder();<br />    stringHolder.Strings.Add("string 1");<br />    stringHolder.Strings.Add("string number 2");<br />    stringHolder.PrintUsing(Console.WriteLine);<br />    stringHolder.PrintUsing(p =&gt; Console.WriteLine(p.ToUpper()));<br />}</pre><br /><p>Nothing too complex.&nbsp; Add some strings and call the method named PrintUsing.&nbsp; But have a look at those two PrintUsing statements.&nbsp; What do you see?</p><br /><p>The first one says we want to do the print using Console.Writeline.&nbsp; That’s easy enough to read, but what about the second one?&nbsp; The second one has one of those funny =&gt; operators – it’s a lambda function.&nbsp; A method defined in line.</p><br /><p>What this method is saying is that for each string to be printed, pass it in as a parameter named “p” to a method that has no name (it’s declared inline so needs no name).&nbsp; That method will call Console.WriteLine, passing to it the string once it has been converted to Uppercase.&nbsp; Pretty cool.</p><br /><h4>The StringHolder Class and Action&lt;T&gt;</h4><br /><p>So let’s implement the class</p><pre class="brush:csharp">public class StringHolder<br />{<br />    public StringHolder()<br />    {<br />        Strings = new List&lt;string&gt;();<br />    }<br /><br />    public List&lt;string&gt; Strings { get; private set; }<br /><br />    public void PrintUsing(Action&lt;string&gt; action)<br />    {<br />        foreach (var part in Strings)<br />        {<br />            action(part);<br />        }<br />    }<br />}</pre><br /><p>Here we see something interesting.&nbsp; Have a look at the parameter for the PrintUsing method – it is looking for an Action&lt;string&gt;.&nbsp; An Action&lt;T&gt; is a .NET type for a lambda function that returns a void.&nbsp; The &lt;T&gt; type is the parameter to pass to the method.&nbsp; If we used Action&lt;string,int&gt; we would be wanting two parameters; a string and an integer.</p><br /><p>What we also see is that inside the method we simply call the action passed in as if it were a normal method, including the passing of the parameters.&nbsp; Quite elegant and simple.</p><br /><h4>Functions vs Actions</h4><br /><p>So how about we now expand things a little and add a few extra lines to the end of our test as so</p><pre class="brush:csharp">var averageLength = stringHolder.CustomFunction(l =&gt; l.Sum(p =&gt; p.Length)/l.Count);<br />Console.WriteLine("Average length: " + averageLength);</pre><br /><p>We now want to allow people to supply a custom function so that they can apply if to our entire list.&nbsp; So instead of giving them one string at a time, we’re going to send them the whole string list and they can manipulate it as they choose.</p><br /><p>In this case we’re going to work out the average length of the strings in the list.&nbsp; To do it we add up the length of all the strings using Linq’s Sum method, and then divide it by the number of strings in the list.</p><br /><p>Now what do we have to add to our class in order to support this?&nbsp; As it turns out, we have to add just 3 lines:</p><pre class="brush:csharp">public T CustomFunction&lt;T&gt;(Func&lt;List&lt;string&gt;,T&gt; function)<br />{<br />    return function(Strings);<br />}</pre><br /><p>Notice the Func&lt;List&lt;string&gt;,T&gt; type on the parameter. It’s just like the Action&lt;T&gt; we looked at earlier, but with a slight difference. We now have two types being listed.&nbsp; The parameter types and the return type.&nbsp; The return type is always the last type in the type list.</p><br /><p>Now that it’s declared as a parameter we can call function() just like any other method and then do something with it’s return value.&nbsp; In our case, we’ll just return it.&nbsp; I should also point out that we’re using generics here – the type &lt;T&gt; after the CustomFunction method name says that T is a generic type.&nbsp; In other words the function we pass in can actually return any type it likes, and we’ll pass that back to the calling code.</p><br /><h4>Default Actions and Overrides</h4><br /><p>How can any of this be useful? Well, let’s consider our string class and think about showing a total of the number of strings in the class.&nbsp; I might want a default behaviour, but also allow people to override that behaviour by supplying a different method to use into one of my classes, and I want to be able to do it at run time.</p><br /><p>Here’s how it might work.&nbsp; Let’s start with a test as follows:</p><pre class="brush:csharp">[TestMethod]<br />public void CallAnAction()<br />{<br />    StringHolder stringHolder = new StringHolder();<br />    stringHolder.MyAction();<br />}</pre><br /><p>I simply call the MyAction method on the stringHolder object and it does something.&nbsp; In this example we’ll get it to write the number of strings out to the console as follows (I know, incredibly complex stuff)</p><pre class="brush:csharp">public void MyAction()<br />{<br />    Console.WriteLine("Number of strings: " + Strings.Count);<br />}</pre><br /><p>But I can’t override this behaviour.&nbsp; I could potentially sublcass it and do an overload on the method (assuming I made it virtual), but that’s not really what I want to do.&nbsp; As a different approach I can refactor my class slightly and make the MyAction method a property as shown:</p><pre class="brush:csharp">public class StringHolder<br />{<br />    public StringHolder()<br />    {<br />        Strings = new List&lt;string&gt;();<br />        MyAction = () =&gt; Console.WriteLine("Number of strings: " + Strings.Count);<br />    }<br /><br />    public Action MyAction { get; set; }</pre><br /><p>We’ve now made MyAction an Action property and we supply the default method signature in the constructor.&nbsp; The () at the start of the lambda declaration indicates that there are no parameters for the method.&nbsp; The good thing is that our test remains unchanged and everything works.</p><br /><p>Now we can take this a step further and from our user code supply an alternate behaviour, overriding that defined by the StringHolder class as shown here:</p><pre class="brush:csharp">[TestMethod]<br />public void CallAnAction()<br />{<br />    StringHolder stringHolder = new StringHolder();<br />    stringHolder.MyAction = () =&gt; Console.WriteLine("Alternate " + stringHolder.Strings.Count);<br />    stringHolder.MyAction();<br />}</pre><br /><p>We set the property value to be the new lambda function we’ve defined and we’re all set.&nbsp; This time when we call the MyAction() method the program will use the newly supplied lambda method we’ve supplied and show the alternate output.</p><br /><h4>Conclusion</h4><br /><p>What we’ve done is overridden the behaviour of our StringHolder class at runtime avoiding the hassle of subclassing, dependency injection or any other compile time techniques we might use.&nbsp; It’s an easy and simple way to provide hooks into your classes where you want to have a standard behaviour that can be overridden.</p>