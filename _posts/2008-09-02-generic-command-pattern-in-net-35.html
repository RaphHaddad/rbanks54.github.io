---
layout: post
title: A Generic Command Pattern in .NET 3.5
date: '2008-09-02T10:03:00.001+10:00'
author: Richard Banks
tags:
- readify
- ".net"
- development
modified_time: '2008-09-02T10:03:10.132+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-4632459519169144409
blogger_orig_url: http://www.richard-banks.org/2008/09/generic-command-pattern-in-net-35.html
---

<p>The command pattern can be a powerful thing to use and yet it can be a right royal pain in the ar... let's just say it's annoying to implement it at time.&nbsp; Why? Because each individual command needs to be represented as an object and in a system that supports many commands you end up with a class explosion.</p> <p>For those of you who need a refresher on the command pattern it is stated as follows:</p> <blockquote> <p>The command pattern encapsulates a request as an object, thereby letting you parameterise other objects with different requests, queue or log requests, and support undoable operations.</p></blockquote> <p>Yeah, great - OK so in plain English that means you create classes to represent commands and those command classes simply make calls to other objects when you execute them.&nbsp; It's a fairly simple pattern.</p> <p>So let's take as an example the command pattern implementation from the awesome Head First Design Patterns book and implement it in .NET instead of Java.</p> <p>First we declare an interface for our command objects:</p><pre class="codeblock">    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">interface</span> <span style="color: rgb(43,145,175)">ICommand<br /></span>    {<br />        <span style="color: rgb(0,0,255)">void</span> Execute();<br />    }</pre><br /><p>Then we create a command to turn a light on:</p><pre class="codeblock">    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">LightOnCommand</span> : <span style="color: rgb(43,145,175)">ICommand<br /></span>    {<br />        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">Light</span> light;<br /><br />        <span style="color: rgb(0,0,255)">public</span> LightOnCommand(<span style="color: rgb(43,145,175)">Light</span> light)<br />        {<br />            <span style="color: rgb(0,0,255)">this</span>.light = light;<br />        }<br /><br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> Execute()<br />        {<br />            light.On();<br />        }<br />    }</pre><br /><p>And finally we create a simple remote control class:</p><pre class="codeblock">    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">SimpleRemoteControl<br /></span>    {<br />        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">ICommand</span> slot;<br />        <br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> SetCommand(<span style="color: rgb(43,145,175)">ICommand</span> command)<br />        {<br />            slot = command;<br />        }<br /><br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> ButtonWasPressed()<br />        {<br />            slot.Execute();<br />        }<br />    }</pre><br /><p>So now if we wanted to use this in our code we could have a test like the following:</p><pre class="codeblock">[<span style="color: rgb(43,145,175)">TestMethod</span>]<br /><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> BasicExecuteTest()<br />{<br />    <span style="color: rgb(43,145,175)">SimpleRemoteControl</span> remote = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">SimpleRemoteControl</span>();<br />    <span style="color: rgb(43,145,175)">Light</span> light = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Light</span>();<br />    <span style="color: rgb(43,145,175)">LightOnCommand</span> lightOn = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">LightOnCommand</span>(light);<br />    remote.SetCommand(lightOn);<br />    remote.ButtonWasPressed();<br />    <span style="color: rgb(43,145,175)">Assert</span>.IsTrue(light.IsOn);<br />}</pre><br /><p>Easy enough.&nbsp; But now, let's say we want to add a command to turn our light off.&nbsp; We would have to implement a new LightOffCommand class.&nbsp; If we were using a TV remote we would then need commands for each of the channels, the volume buttons, a channel up/down button, an input selector, etc.&nbsp; As you can imagine once you start creating a class per command you can easily end up in with hundreds of classes all of which look pretty much the same.</p><br /><p>This is where generics and lambda expressions in .NET 3.5 can help us.</p><br /><p>Let's take our ICommand interface and implement it with a generic class:</p><pre class="codeblock"><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">Command</span>&lt;T&gt; : <span style="color: rgb(43,145,175)">ICommand<br /></span>{<br />    <span style="color: rgb(0,0,255)">private</span> T target;<br />    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">Action</span>&lt;T&gt; command;<br /><br />    <span style="color: rgb(0,0,255)">public</span> Command(T target, <span style="color: rgb(43,145,175)">Action</span>&lt;T&gt; command)<br />    {<br />        <span style="color: rgb(0,0,255)">this</span>.target = target;<br />        <span style="color: rgb(0,0,255)">this</span>.command = command;<br />    }<br /><br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> Execute()<br />    {<br />        command(target);<br />    }<br />}</pre><br /><p>We now have a single class that is able to represent a whole range of commands without getting us into the class explosion situation we had previously.</p><br /><p>The Action&lt;T&gt; command is a variable that will hold a lambda expression that doesn't return a value.&nbsp; If we wanted a value returned we would need to use Func&lt;T, TResult&gt; instead.</p><br /><p>When we want to create a command we now pass the object we want to take action on, as well as a command to execute. So now we can refactor our test and change it as follows:</p><pre class="codeblock">[<span style="color: rgb(43,145,175)">TestMethod</span>]<br /><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> BasicExecuteTest()<br />{<br />    <span style="color: rgb(43,145,175)">SimpleRemoteControl</span> remote = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">SimpleRemoteControl</span>();<br />    <span style="color: rgb(43,145,175)">Light</span> light = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Light</span>();<br />    <span style="color: rgb(0,0,255)">var</span> lightOn = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Command</span>&lt;<span style="color: rgb(43,145,175)">Light</span>&gt;(light, l =&gt; l.On());<br />    remote.SetCommand(lightOn);<br />    remote.ButtonWasPressed();<br />    <span style="color: rgb(43,145,175)">Assert</span>.IsTrue(light.IsOn);<br />}</pre><br /><p>So here we see that the LightOnCommand has been replaced with the new generic command Command&lt;Light&gt; command and that we are passing the object to target with our command as well as a lambda expression for the command itself.</p><br /><p>What this means is that we can now declare commands as follows without needing to create individual classes for each command:</p><pre class="codeblock"><span style="color: rgb(0,0,255)">var</span> lightOff = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Command</span>&lt;<span style="color: rgb(43,145,175)">Light</span>&gt;(light, l =&gt; l.Off());<br /><span style="color: rgb(0,0,255)">var</span> strobeLight = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Command</span>&lt;<span style="color: rgb(43,145,175)">Light</span>&gt;(light, l =&gt;<br />    { <br />        l.On();<br />        l.Off();<br />        l.On();<br />        l.Off();<br />        l.On();<br />    });</pre><br /><p>So much nicer!</p><br /><p>We now have an implementation of the command pattern that is not only powerful, but much easier to code and maintain as well.</p><br /><p>Of course, if there's a lot of command reuse in your application this implementation of the command pattern might not be for you as it could easily lead to cut &amp; paste development, though with judicious use of an IoC container you should be able to overcome that particular issue.</p>  