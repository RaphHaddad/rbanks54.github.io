---
layout: post
title: 'Mocking Comparison – Part 1: The Basics'
date: '2010-07-20T00:38:00.003+10:00'
author: Richard Banks
tags:
- mocking
modified_time: '2010-08-06T08:53:32.996+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-6463074561001440735
blogger_orig_url: http://www.richard-banks.org/2010/07/mocking-comparison-part-1-basics.html
---

<p>I recently gave a talk on mocking at the <a title="DDD Sydney Web Site" href="http://www.dddsydney.com" target="_blank">DDD Sydney</a> conference called “You Look Like A Monkey and You Smell Like One Too”.&#160; In it I not only got to call the audience various names and get mocked in return, but I also showed a number of features of mock frameworks and how they can be used.&#160; Essentially it was a comparison of a number of mock frameworks, with a particular focus on a few of the main open source ones out there and a great new comer – specifically <a href="http://www.ayende.com/projects/rhino-mocks.aspx" target="_blank">RhinoMocks</a>, <a href="http://code.google.com/p/moq/" target="_blank">Moq</a> and <a href="http://nsubstitute.github.com/" target="_blank">NSubstitute</a>.</p>  <p>This is part 1 of series running through the code I had on screen and providing some thoughts on the pros and cons of each framework in the context of the scenario I’m showing.&#160; This first part will be longer than the others simply because we have to put some ground work in place.&#160; So, let’s stop wasting time and get started…</p>  <h3>What Are We Testing?</h3>  <p>All right, so in order to do any mocking we really should have an application to test.&#160; For the purposes of this series the code is a simple class library.&#160; It does nothing useful in the real world, but it does give us something to test.&#160; It’s a pseudo “zoo” featuring monkeys, zoo keepers and tourists.</p>  <h4>The IMonkey Interface</h4>  <p>Every zoo needs a monkey, and thus we need a monkey right? Of course we do! However, because the monkeys haven’t been tested yet,&#160; the monkeys aren’t yet on display (or at least we haven’t written the code for them yet) so all we have to interact with for now is an IMonkey interface as follows:</p>  <pre class="brush:csharp">public interface IMonkey<br />{<br /> string Name { get; set; }<br /> bool TryAddFleas(int numberOfFleas);<br /> int CurrentFleaCount();<br /> void Clean();<br /> bool IsAwake(DateTime timeOfDay);<br /> void BananaReady(object sender, BananaEventArgs e);<br /> event EventHandler&lt;EventArgs&gt; Dance;<br /> IZooKeeper Keeper();<br />}</pre><h4>The IZooKeeper Interface and the ZooKeeper</h4><p>Monkeys have Keepers, and since all staff in any organisation are just “resources” and thus completely interchangeable (grrr – don’t get me started on this kind of thinking!) we should have an IZooKeeper interface.&#160; We are also lucky enough to actually have a standard ZooKeeper definition as well.&#160; Here’s the code:</p><pre class="brush:csharp">public interface IZooKeeper<br />{<br /> event EventHandler&lt;BananaEventArgs&gt; OnBananaReady;<br /> IMonkey AssignedMonkey { get; set; }<br /> void CleanMonkey();<br /> void FeedMonkeys();<br />}</pre><pre class="brush:csharp">public class ZooKeeper : IZooKeeper<br />{<br /> public event EventHandler&lt;BananaEventArgs&gt; OnBananaReady;<br /><br /> public IMonkey AssignedMonkey { get; set; }<br /> <br /> public void CleanMonkey()<br /> {<br />  if (AssignedMonkey == null) return;<br />  if (AssignedMonkey.CurrentFleaCount() &lt; 10) return;<br />  if (AssignedMonkey.IsAwake(DateTime.Now))<br />   AssignedMonkey.Clean();<br /> }<br /><br /> public void FeedMonkeys()<br /> {<br />  if (OnBananaReady != null)<br />  {<br />   OnBananaReady(this, new BananaEventArgs(true));<br />  }<br /> }<br />}<br /><br />public class BananaEventArgs : EventArgs<br />{<br /> public BananaEventArgs(bool isRipe)<br /> {<br />  IsRipe = isRipe;<br /> }<br /><br /> public bool IsRipe { get; private set; }<br />}</pre><br /><h4>Tourists!</h4><p>Every zoo needs tourists, and in this case we want concrete instances of tourists, not just some definition of what a tourist should be.&#160; Our tourists are a little weird in that every tourist that comes to our zoo expects our monkeys to dance, and should that happen then they’ll take a photo.&#160; Here’s the code:</p><br /><pre class="brush:csharp">public class Tourist<br />{<br /> IMonkey monkey;<br /><br /> ~Tourist()<br /> {<br />  if (monkey!= null)<br />   monkey.Dance -= Look_ADancingMonkey;<br /> }<br /><br /> public int PhotosTaken { get; private set; }<br /><br /> public void SeeAMonkey(IMonkey monkey)<br /> {<br />  if (this.monkey != monkey &amp;&amp; this.monkey != null)<br />   this.monkey.Dance -= Look_ADancingMonkey;<br /><br />  this.monkey = monkey;<br />  monkey.Dance += Look_ADancingMonkey;<br /> }<br /><br /> public void Look_ADancingMonkey(object sender, EventArgs args)<br /> {<br />  if (((IMonkey)sender).CurrentFleaCount() &lt;= 100)<br />  {<br />   TakeAPhoto((IMonkey)sender);<br />  }<br />         return;<br /> }<br /><br /> private void TakeAPhoto(IMonkey monkey)<br /> {<br />  PhotosTaken++;<br />  Console.WriteLine(monkey.Name);<br /> }<br />}</pre><br /><h3>Record/Replay Is Dead</h3><p>OK.&#160; That’s done, now let’s get into it.&#160; If you’ve used a mocking framework in previous years you may have used Record/Replay syntax.&#160; The idea being you record the steps you want your mock to perform, then switch to replay mode, do the steps again and assert everything worked.&#160; Here’s what Record/Replay looks like using Rhino Mocks in an XUnit test harness:</p><br /><pre class="brush:csharp">private string testName = &quot;Spike&quot;;<br /><br />[Fact]<br />public void Rhino_record_replay()<br />{<br /> var repository = new MockRepository();<br /> var monkey = repository.StrictMock&lt;IMonkey&gt;();<br /><br /> //In record mode at the moment<br /> Expect.Call(monkey.Name).Return(testName);<br /><br /> //Now in replay mode<br /> repository.ReplayAll();<br /> var actual = monkey.Name;<br /><br /> Assert.Equal(testName, actual);<br />}</pre><p>As you can see, we create a MockRepository object, ask the repository to give us a new mock object for a, call the method we want to mock out once, set the expected return value, then we switch to Replay mode and make the call again before finally doing our assertions.</p><p>From the small sample code you may be forgiven for thinking that the code isn’t all that bad, however the fact that you have to think about what mode you’re takes you out of the mode of thinking about what it is you’re actually meant to test, and that’s not a good thing. To make matters worse, this is a simple case.&#160; When you get into complex cases, record/replay is downright painful and the amount of repeated code that has to happen in order to set up expectations is often overwhelming and confusing.</p><p>Oh, you’ll also notice that the sample code is using a StrictMock.&#160; If this is what you’re doing, then stop it! StrictMocks are a great way to make your tests brittle and hard to maintain and should be avoided wherever possible.&#160; Just search for why strict mocks are bad on your favourite search engine and you’ll no doubt find more information about it.</p><h3>Use Arrange Act Assert Instead</h3><p>Let’s now look at the same code using Rhino Mocks in AAA syntax mode.&#160; In case you’re not aware of this, AAA syntax is a way of structuring the tests where you Arrange any pre-requisites for the test, Act on the class under test and then Assert that things occurred as expected.</p><pre class="brush:csharp">[Fact]<br />public void Rhino_arrange_act_assert()<br />{<br /> //Arrange<br /> var monkey = MockRepository.GenerateMock&lt;IMonkey&gt;();<br /> monkey.Stub(m =&gt; m.Name).Return(testName);<br /><br /> //Act<br /> var actual = monkey.Name;<br /><br /> //Assert<br /> Assert.Equal(testName, actual);<br />}</pre><p>As you can see, the code is simpler, structured more cleanly and is also easier to read.&#160; In large test libraries this makes things much more maintainable, which is a good thing.</p><h3>The Moq Version</h3><p>So far the code has used the Rhino Mocks framework.&#160; Another very popular framework is Moq.&#160; Here’s what the same test in Moq looks like:</p><pre class="brush:csharp">[Fact]<br />public void Moq_arrange_act_assert()<br />{<br /> var monkey = new Mock&lt;IMonkey&gt;();<br /> monkey.Setup(m =&gt; m.Name).Returns(testName);<br /><br /> var actual = monkey.Object.Name;<br /><br /> Assert.Equal(testName, actual);<br />}</pre><p>Moq became popular when it was released because no other test framework could do what it did in terms of setting up expectations via lambdas and providing such an easy way of performing AAA style tests.</p><p>Over time the other frameworks have caught up, and for me personally, the fact that Moq has a distinct delineation between the mock and the object being mocked (i.e. the monkey.Object code) adds clutter to the test code that I don’t like.&#160; Others like that clarity, but I personally find it just gets in the way.</p><p>On the other hand, mock object creation is far less verbose, which is a good thing.</p><h3>NSubstitute</h3><p>Finally, the new kid on the block.&#160; NSubstitute’s code looks like the following:</p><pre class="brush:csharp">[Fact]<br />public void Nsubstitute_arrange_act_assert()<br />{<br /> var monkey = Substitute.For&lt;IMonkey&gt;();<br /> monkey.Name.Returns(testName);<br /><br /> var actual = monkey.Name;<br /><br /> Assert.Equal(testName, actual);<br />}</pre><p>What you  see is that the code is much terser than Rhino and Moq.&#160; A mock is created as a “substitute for” a IMonkey and we don’t need to use lambdas to set return values for a mocked property, greatly improving readability of the test code and making test code feel more expressive.</p><p>My preference of the three for the basic syntax and coding? NSubstitute.</p><p>&nbsp;</p><p>Other posts in this series:<ul><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-2-properties.html">2: Properties</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-3-interactions.html">3: Interactions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-4-parameter.html">4: Parameter Constraints</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-5-repetitions.html">5: Repetitions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-6-multiple.html">6: Multiple Calls</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-7-exceptions.html">7: Exceptions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-8-recursive.html">8: Recursive Mocks</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-9-functions.html">9: Functions</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-10-events.html">10: Events</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-11-multiple.html">11: Multiple Interfaces</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-12-unmockables.html">12: The UnMockables</a></li></ul></p>