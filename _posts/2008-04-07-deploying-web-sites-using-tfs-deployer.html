---
layout: post
title: Deploying Web Sites using TFS Deployer, PowerShell and FTP
date: '2008-04-07T18:17:00.001+10:00'
author: Richard Banks
tags:
- readify
- TFS
- powershell
modified_time: '2008-04-07T18:17:00.922+10:00'
thumbnail: http://lh4.google.com/rbanks54/R_nYd35nb2I/AAAAAAAAAT4/y8VseOlnVpM/s72-c/deploy1_thumb%5B2%5D.png
blogger_id: tag:blogger.com,1999:blog-13321238.post-2295061555959136055
blogger_orig_url: http://www.richard-banks.org/2008/04/deploying-web-sites-using-tfs-deployer.html
---

<p>I had a situation recently where I needed to deploy a web site into a production environment from TFS where the only way we could transfer files was via FTP.&nbsp; In case it's not obvious I didn't want to deploy every time the build ran, but rather, only when the build was declared good.</p> <p>To do this, I used <a href="http://www.codeplex.com/tfsdeployer" target="_blank">TFS Deployer</a> (developed by <a href="http://notgartner.wordpress.com/2006/12/16/getting-started-with-tfs-deployer/" target="_blank">Mitch</a>, <a href="http://blogs.madtechnology.net/blogs/chris/default.aspx" target="_blank">Chris</a>, <a href="http://showusyourcode.spaces.live.com/" target="_blank">Darren</a> and Geoff of <a href="http://www.readify.net" target="_blank">Readify</a>) available from <a href="http://www.codeplex.com/tfsdeployer" target="_blank">CodePlex</a>. TFS Deployer is a small utility that monitors changes in the build quality of a TFS Team Build and initiates a <a href="http://www.microsoft.com/windowsserver2003/technologies/management/powershell/default.mspx" target="_blank">PowerShell</a> script based on what the change in build quality was.&nbsp; It runs something like this:</p> <p><a href="http://lh5.google.com/rbanks54/R_nYdH5nb1I/AAAAAAAAATw/CN7lOU4aceI/deploy1%5B4%5D.png"><img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" border="0" alt="deploy1" src="http://lh4.google.com/rbanks54/R_nYd35nb2I/AAAAAAAAAT4/y8VseOlnVpM/deploy1_thumb%5B2%5D.png" width="640" height="376"></a> </p> <p>A TeamBuild is executed and after completion the build has a quality of "Unexamined"</p> <p>1. Someone runs some tests, checks the build is OK and decides the build quality can be progressed</p> <p>2. TFS updates the build quality and raises an alert that the build quality has changed</p> <p>3. On startup TFS Deployer registers itself as a listener for build quality events and picks up the alert.&nbsp; It examines the old/new qualities and determines if a PowerShell script should be run. If a script needs to be run then PowerShell is started and the script executed.</p> <p>4. Results from the script are emailed to a specified email address of distribution list.</p> <p><a href="http://lh6.google.com/rbanks54/R_nYeX5nb3I/AAAAAAAAAUA/X8OosFUwdko/clip_image002%5B6%5D.jpg"><img style="border-top-width: 0px; border-left-width: 0px; border-bottom-width: 0px; border-right-width: 0px" border="0" alt="clip_image002" src="http://lh4.google.com/rbanks54/R_nYe35nb4I/AAAAAAAAAUI/I2EGrV6SVc8/clip_image002_thumb%5B3%5D.jpg" width="702" height="191"></a></p> <p>&nbsp;</p> <h3>TFS Deployer Setup</h3> <p>I'll assume that TFS Deployer is installed and set up as per the instructions.&nbsp; To initiate the PowerShell script we set up a deployment mapping as follows:</p><pre class="codeblock"><span style="color: rgb(0,0,255)">    &lt;</span><span style="color: rgb(163,21,21)">Mapping</span><span style="color: rgb(0,0,255)"> </span><span style="color: rgb(255,0,0)">xmlns</span><span style="color: rgb(0,0,255)">=</span>""<br /><span style="color: rgb(0,0,255)">                 </span><span style="color: rgb(255,0,0)">Computer</span><span style="color: rgb(0,0,255)">=</span>"<font color="#0000ff">MyBuildServer</font>"<br /><span style="color: rgb(0,0,255)">                 </span><span style="color: rgb(255,0,0)">OriginalQuality</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">Unexamined</span>"<br /><span style="color: rgb(0,0,255)">                 </span><span style="color: rgb(255,0,0)">NewQuality</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">Released to Production</span>"<br /><span style="color: rgb(0,0,255)">                 </span><span style="color: rgb(255,0,0)">Script</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">DeployToProd.ps1</span>"<br /><span style="color: rgb(0,0,255)">                 </span><span style="color: rgb(255,0,0)">NotificationAddress</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">you.are@here.com</span>"<span style="color: rgb(0,0,255)"> /&gt;</span></pre><br /><p>That's about it.&nbsp; Pretty tough :-) Now for something a little harder.</p><br /><h3>Getting Ready for Deployment via FTP</h3><br /><p>OK, this is where it could get painful.&nbsp; PowerShell doesn't have any native FTP support. So the first option you have would be to use the native .NET FTP classes from but that's a real pain because you effectively have to implement your own FTP client in PowerShell.&nbsp; No thanks!</p><br /><p>But don't despair - the open source <a href="http://www.indyproject.org/" target="_blank">Indy Project</a> is a project that provides a wrapper and helper functions around for all the FTP calls you might want to make (plus a whole bunch of other low level networking goodness) and they have a <a href="http://www.indyproject.org/Sockets/Download/Files/DotNet.de.aspx" target="_blank">.NET version</a> of their library.&nbsp; Grab a copy of that (and the Mono.Security DLL that goes with it) and you'll have all you really need to get going.</p><br /><p>I should also mention that because I'm deploying to a production box I'm assuming that IIS is already set up - after all it's very unlikely that we'd be dropping the IIS virtual directory on every deployment.&nbsp; We'll just be dropping our files in over the top of whatever is already there.</p><br /><h3>The PowerShell Script</h3><br /><p>Time for the script itself - I'll just take this section at a time.&nbsp; First up, the script is called from TFS Deployer which means we have access to the TFS build data for the build that just had it's quality changed. So we're going to set two variables for the folders where things live.&nbsp; $loc is the root of the build drop location, and $sourcefiles is where the published web site live (ie the stuff we need to deploy).</p><pre class="codeblock">Set-Location $TfsDeployerBuildData.DropLocation;<br />$loc = get-location;<br />set-location "Mixed Platforms\Release\_PublishedWebSites\";<br />$sourceFiles = get-location;</pre><br /><h3>Opening and Closing FTP Connections</h3><br /><p>Next we're going to create a few PowerShell script functions to support the opening and closing of our FTP connections.</p><br /><p>When we open the connection we're first going to use the .NET assembly loader to bring in the Indy.Sockets library then use the methods in that to make the connection and then return the FTP connection object from the function.&nbsp; The close-method is a bit simpler in that we simply wrap the call to the FTP-disconnect. (yes, it's not really required as a function, but you never know when you might want to add logging, error handling, etc).</p><pre class="codeblock">function Open-FTPConnection($ftphost, $username, $password) {<br /><br />[void][Reflection.Assembly]::LoadFrom("C:\path\to\Indy.Sockets.dll")<br />  $ftp = new-object Indy.Sockets.FTP  <br />  $ftp.Disconnect()<br />  $ftp.Host = $ftphost<br />  $ftp.Username = $username<br />  $ftp.Password = $password<br />  $ftp.Connect()<br />  $ftp.Passive=$true;<br />  return $ftp<br />}<br /><br />function Close-FTPConnection($ftp) {<br />    $ftp.Disconnect();<br />}</pre><br /><p>Oh - For those not familiar with PowerShell syntax the :: operator lets us call static methods on a type and the [] wrap a type identifier.&nbsp; </p><br /><h3>FTP Miscellaneous Functions</h3><br /><p>Next we define a few more functions just to wrap up some of the basic FTP calls.&nbsp; Note: Download-FTPFile isn't used - it's just there for your reference.</p><pre class="codeblock">function Get-FTPCurrentLocation($ftp) {<br />  return $ftp.RetrieveCurrentDir();<br />}<br /><br />function Download-FTPFile($ftp, $sourceFileName, $targetDir) {<br />    $ftp.Get($sourceFileName, ($targetDir + $sourceFileName), $true, $false);<br />}<br /><br />function Upload-FTPFile($ftp, $sourceFileName, $targetFileName) {<br />    $ftp.Put($sourceFileName, $targetFileName, $false);<br />}</pre><br /><p>Nothing overly complex in that.</p><br /><h3>Getting the Contents of an FTP Folder</h3><br /><p>Now we get to something a bit more interesting.&nbsp; Here we're creating a function that iterates over the contents of the FTP location and optionally deleting files as it goes.&nbsp; It will return a list of sub-folders in the folder for later use.</p><br /><p>The function works as follows:</p><br /><p>1. Get the directory listing for the current FTP location.</p><br /><p>2. Checks if the current directory is the root folder or not - appends a trailing slash if it isn't.</p><br /><p>3. For each item in the folder...</p><br /><p>3a. Parses the string to get the file name</p><br /><p>3b. Checks if the item is a directory or a file (directories have a "d" in their attributes)</p><br /><p>3c. For folders we return the full path to the sub-folder.</p><br /><p>3d. For files we check the delete flag and nuke the file if it is set.</p><br /><p>You'll notice that the $result.add($name) call is cast to a [void].&nbsp; If we don't do this then when we return from the function we get 2 sets of files.&nbsp; One from the $result object and one for each file name that was written to the output stream by the $result.add() method call. </p><pre class="codeblock">function Get-FTPFolders($ftp, [bool]$removeFiles) {<br />    $ls = new-object System.Collections.Specialized.StringCollection;    <br />    $result = new-object System.Collections.Specialized.StringCollection;    <br />    $ftp.List($ls, "", $true);<br />    $currdir = Get-FTPCurrentLocation($ftp);<br />    if($currdir -ne "/") {<br />        $currdir = $currdir + "/";<br />    }<br />    foreach ($item in $ls)<br />    {<br />        [string[]]$fields=[Regex]::Split($item, " +");<br />        $startField=8;   #the file/directory name starts after 8 fields<br />        [string]$name=$currdir;<br /><br />        #make sure we join up file names that were split (ie ones with spaces)<br />        for ($field=$startField; $field -lt $fields.Length; $field++)<br />        {<br />            if ($field -eq $startField)<br />            {<br />              $temp = ""<br />            } else<br />            {<br />              $temp = " "<br />            }<br />            $name += $temp + $fields[$field];<br />        }<br />        <br />        if ($item.StartsWith("d")) <br />        { #directory<br />            [void]$result.Add($name);<br />        } <br />        else <br />        {<br />        if ($item.StartsWith("-")) { #files have '-' as first character<br />            if ($removeFiles)<br />                {<br />                $ftp.Delete($name);<br />                }<br />            }<br />        }<br />    }<br />    return $result<br />}</pre><br /><h3>Iterating/Deleting the FTP Folder Structure</h3><br /><p>Next I have two more methods.&nbsp; One to read through the contents of the FTP folder hierarchy, and one to clear it out.&nbsp; Both methods are roughly the same with only variations for the call to Get-FTPFolders.</p><pre class="codeblock">function Get-FTPTree($ftp)<br />{<br />    $thisdir = Get-FTPCurrentLocation($ftp);<br />    $thisdir;<br />    $subfolders = (Get-FTPFolders $ftp $false);<br />    if ($subfolders -ne $null) {<br />        foreach ($xitem in $subfolders)<br />        {<br />            $ftp.ChangeDir($xitem);<br />            Get-FTPTree($ftp);<br />        }<br />    }<br />    $ftp.ChangeDir($thisdir);<br />    return;<br />}<br /><br />function Clean-FTPTree($ftp)<br />{<br />    $thisdir = Get-FTPCurrentLocation($ftp);<br />    $thisdir;<br />    $subfolders = (Get-FTPFolders $ftp $true);<br />    if ($subfolders -ne $null) {<br />        foreach ($xitem in $subfolders)<br />        {<br />            $ftp.ChangeDir($xitem);<br />            Clean-FTPTree($ftp);<br />            $foldername = $xitem.split("/");<br />            $ftp.ChangeDir($thisdir);<br />            $ftp.RemoveDir($foldername[$foldername.Count - 1]);<br />        }<br />    }<br />    $ftp.ChangeDir($thisdir);<br />    return;<br />}</pre><br /><p>Note that in the Clean method we delete folders by stripping the folder name off the end of the full path, stepping back up a level and then calling the removedir method.&nbsp; It's not pretty, but it works.</p><br /><h3>Putting it all Together</h3><br /><p>Now we have everything in place let's actually do what we need to do. Here's what happens:</p><br /><p>1. We make the connection to the FTP server.</p><br /><p>2. We clean out the existing FTP tree</p><br /><p>3. We get a list of all the files we're going to upload.</p><br /><p>4. We copy each file individually to the ftp server, creating folders where required (note the filename processing). </p><br /><p>5. Just to make sure things are right - we get the contents of the site so we can check the upload worked.</p><br /><p>6. Close the connection - we're done!</p><pre class="codeblock">#Make a connection<br /><br />$f = Open-FTPConnection "my.ftp.server.com" "ftp_user_account" "ftp_account_password";<br /><br />write-output "----CLEANING----";<br />Clean-FTPTree($f);<br /><br />write-output "----UPLOADING----";<br /><br />$localfiles = (get-childitem $sourcefiles -r)<br />foreach ($localfile in $localfiles) {<br />  $remfilename = $localfile.FullName.Replace($sourcefiles.ProviderPath, "");<br />  $remfilename = $remfilename.Replace("\", "/");<br />  if ($localfile.Attributes -eq "Directory") {<br />    Write-Output ("Creating " + $localfile.FullName + ":" + $remfilename);<br />    $f.MakeDir($remfilename);<br />  }<br />  else {<br />   Write-Output ("   Uploading " + $localfile.FullName + ":" + $remfilename);<br />   upload-ftpfile $f $localfile.FullName $remfilename<br />   $remfilename;<br /> }<br />}<br /><br />write-output "----VERIFYING----";<br />Get-FTPTree($f);<br /><br />Close-FTPConnection $f </pre><br /><p>One thing you might notice is that we use the ProviderPath property of the $sourcefiles variable.&nbsp; This is because $sourcefiles is a PathInfo object and when TFS Deployer runs the PathInfo will contain a UNC path pointing to a network share - if we just use the Path property then we will get the PowerShell Provider identifier in the string causing the FTP upload to fail.</p><br /><p>&nbsp;</p><br /><p>Hopefully this is a good starting point for you if you are trying to do the same thing.</p>  