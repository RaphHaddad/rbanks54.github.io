---
layout: post
title: Using Parallel Task Library to Unit Test Threading Issues
date: '2011-09-02T12:04:00.001+10:00'
author: Richard Banks
tags:
- testing
- development
modified_time: '2011-09-02T12:21:05.493+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-2394908674364747264
blogger_orig_url: http://www.richard-banks.org/2011/09/using-parallel-task-library-to-unit.html
---

I was doing some work recently on a demo application where data was being pulled in from multiple locations and being added to a collection that was also being iterated over in the same method.&nbsp; Because this data was arriving on multiple threads (i.e. async network call backs for example) I’d occasionally see the usual “collection was modified” error messages indicating that another thread had altered the collection while the first was iterating over it.&nbsp; Obvious threading bug, #FacePlam applied.<br /><br />While it can be complex at times to find these kinds of errors, in this case it was fairly easy to diagnose and fix, so following good bug fix practices I took the standard approach of writing a test to prove the bug exists, fixing the code and then running the test again to prove it’s fixed.<br /><br />Now, it should be noted that testing threading issues in a deterministic way is nigh on impossible, and there is no guarantee that a unit test for threading issues will genuinely prove the code bug free, however the approach taken here was good enough to throw the threading exception each and every time I ran the test and also the throw the exception on the build server.<br /><br />Here’s the code:<br /><br /><div class="wlWriterEditableSmartContent" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:0d6b495d-8837-495e-b3a7-7b6cc666c082" style="display: inline; float: none; margin: 0px; padding: 0px;"><pre class="brush: c#;">[TestMethod]<br />public void ThreadingFun()<br />{<br />    InitializeControllerAndGroup();<br /><br />    Task[] tasks = new Task[10]<br />                            {<br />                                Task.Factory.StartNew(() =&gt; MakeMove(1)),<br />                                Task.Factory.StartNew(() =&gt; MakeMove(2)),<br />                                Task.Factory.StartNew(() =&gt; MakeMove(1)),<br />                                Task.Factory.StartNew(() =&gt; MakeMove(2)),<br />                                Task.Factory.StartNew(() =&gt; MakeMove(1)),<br />                                Task.Factory.StartNew(() =&gt; MakeMove(2)),<br />                                Task.Factory.StartNew(() =&gt; MakeMove(1)),<br />                                Task.Factory.StartNew(() =&gt; MakeMove(2)),<br />                                Task.Factory.StartNew(() =&gt; MakeMove(1)),<br />                                Task.Factory.StartNew(() =&gt; MakeMove(2)),<br />                            };<br />    Task.WaitAll(tasks);<br />}</pre></div>Ignore the first line, that’s just where the collection is being initialised.&nbsp; Also ignore the fact that there’s no Assert statements in this code.&nbsp; The test passes if we have no threading exceptions thrown and fails if we have one.<br /><br />The important thing here is to see how easy it is to fire off a lot of threads in a single, easy to read unit test without all the usual threading plumbing code that would litter something like this.<br /><br />The way it works is that we define a set of tasks via the Task Parallel Library (part of .NET 4.0) each of which calls the code where we have our threading problem.&nbsp; When Task.Factory.StartNew() is called the Task Parallel Library (TPL) immediately creates a new thread and calls the method returning control to our code along with a Task object so would can check the state of the task or cancel it if so desired.&nbsp; In this case we don’t care and immediately start another thread as soon as possible.<br /><br />We then use the Task.WaitAll statement to wait until all the Tasks we defined are completed so that the test doesn’t complete prematurely.&nbsp; Too easy.<br /><br />Note that we could also just as easily have used Parallel.Invoke for this.&nbsp; The same test using Parallel Invoke would be something like this:<br /><br /><div class="wlWriterEditableSmartContent" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:fd79ed64-26d2-4934-bb6e-256d57868d3b" style="display: inline; float: none; margin: 0px; padding: 0px;"><pre class="brush: text;">[TestMethod]<br />public void ParallelInvoke()<br />{<br />    InitializeControllerAndGroup();<br /><br />    Parallel.Invoke(<br />        () =&gt; MakeMove(1),<br />        () =&gt; MakeMove(2),<br />        () =&gt; MakeMove(1),<br />        () =&gt; MakeMove(2),<br />        () =&gt; MakeMove(1),<br />        () =&gt; MakeMove(2),<br />        () =&gt; MakeMove(1),<br />        () =&gt; MakeMove(2),<br />        () =&gt; MakeMove(1),<br />        () =&gt; MakeMove(2)<br />    );<br />}</pre></div>I personally prefer the first approach because I like the more explicit control over the thread creation, though it’s obviously noisier than the Parallel.Invoke version.&nbsp; Note that with Parallel.Invoke you hand over control to the TPL and it figures out how many threads it will use to run the actions you define based on the number of cores available on the machine.<br /><br />Regardless of the method you choose you can take advantage of the TPL to help you unit test your multithreaded code and make your application more resilient.