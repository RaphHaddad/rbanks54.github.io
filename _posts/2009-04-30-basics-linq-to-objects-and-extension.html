---
layout: post
title: 'Basics: LINQ to Objects and Extension Methods'
date: '2009-04-30T15:59:00.001+10:00'
author: Richard Banks
tags:
- ".net"
- development
- basics
modified_time: '2009-04-30T15:59:49.960+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-5580645552993469714
blogger_orig_url: http://www.richard-banks.org/2009/04/basics-linq-to-objects-and-extension.html
---

<p>While it’s true that .NET 3.5 has been out for some time, many people still haven’t had a chance to learn some of the new .NET features as yet simply because they are still tasked with working on .NET 2.0 code and the opportunity hasn’t arisen.</p> <p>This post comes as a direct result of a session I did a short while ago (hi! if you were in the room) where I was explaining some of the LINQ and Extension methods features in .NET 3.5 to a group of developers.&nbsp; I thought it might be worth sharing with you as well.</p> <p>I think the best way to learn something is to try it yourself first, so here’s your mission: take the following strings, sort them alphabetically, and add a prefix to each string showing the count of the word “it” in each sentence using the “[nnn] “ format.&nbsp; Obviously it’s a very contrived example, but it’s hopefully simple enough to get your head around it and it shows how the same goal can be achieved in both .NET 2.0 and 3.5.</p> <p>The strings are:<br>“One it”, “It should have one its”, “Three it it it its”, “NAMBLA has no its”.  <p>Before you continue, why don’t you do just that.&nbsp; Write a small app that meets the requirements and then come back here and read on.  <p></p> <p></p> <h4>A Test Driven Approach</h4> <p>Now those who know me, know that I like to encourage people to write tests first, so it would be remiss of me not to do the same in a blog post.&nbsp; Here’s a simple test that will help us prove that what we want to implement actually works.</p><pre class="code">[<span style="color: rgb(43,145,175)">TestMethod</span>]<br /><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> NonLinqMethodShouldWork()<br />{<br />    <span style="color: rgb(0,0,255)">var</span> s1 = <span style="color: rgb(163,21,21)">"One it"</span>;<br />    <span style="color: rgb(0,0,255)">var</span> s2 = <span style="color: rgb(163,21,21)">"It should have one its"</span>;<br />    <span style="color: rgb(0,0,255)">var</span> s3 = <span style="color: rgb(163,21,21)">"Three it it it its"</span>;<br />    <span style="color: rgb(0,0,255)">var</span> s4 = <span style="color: rgb(163,21,21)">"NAMBLA has no its"</span>;<br />    <span style="color: rgb(0,0,255)">var</span> strings = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(0,0,255)">string</span>&gt; {s1, s2, s3, s4};<br />    <span style="color: rgb(0,0,255)">var</span> result = <span style="color: rgb(43,145,175)">NonLinqSorter</span>.SortAndPrefix(strings);<br />    <span style="color: rgb(43,145,175)">Assert</span>.AreEqual(<span style="color: rgb(163,21,21)">"[1] "</span> + s2, result[0]);<br />    <span style="color: rgb(43,145,175)">Assert</span>.AreEqual(<span style="color: rgb(163,21,21)">"[0] "</span> + s4, result[1]);<br />    <span style="color: rgb(43,145,175)">Assert</span>.AreEqual(<span style="color: rgb(163,21,21)">"[1] "</span> + s1, result[2]);<br />    <span style="color: rgb(43,145,175)">Assert</span>.AreEqual(<span style="color: rgb(163,21,21)">"[3] "</span> + s3, result[3]);<br />    <span style="color: rgb(43,145,175)">Assert</span>.AreEqual(4,result.Count());<br />}<br /></pre><a href="http://11011.net/software/vspaste"></a><br /><p><br>As you can see it’s a straightforward test.&nbsp; We create the 4 strings, place them in a list and then call the SortAndPrefix method (using a static class).&nbsp; From the results list we then Assert() that the output is as we expected.</p><br /><p>Note that I’ve used the var type identifier in most places.&nbsp; This is a .NET 3.5 mechanism that allows the compiler to infer the type of the variable based on what the right hand side of the assignment operator returns.&nbsp; Let’s avoid a discussion over the use of “var” and whether it’s the best way to do things or not and just say that my personal preference is to use var simply because I find it makes the code easier to read.</p><br /><h4>A .NET 2.0 Implementation</h4><br /><p>Now we have our test it’s time to actually write an implementation.&nbsp; Let’s do a .NET 2.0 implementation of it, i.e. without using LINQ or extension methods. You may want to compare it to yours (you did do one, didn’t you?). </p><br /><p>Thinking about the problem and breaking it down we simply want to sort the strings and then for each string count the “it’ words.&nbsp; We then want to add a prefix to the front of each string and return the result as a new list.</p><br /><p>Hopefully you’d end up writing code that looks something like the following:</p><pre class="code"><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">NonLinqSorter<br /></span>{<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(0,0,255)">string</span>&gt; SortAndPrefix(<span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(0,0,255)">string</span>&gt; strings)<br />    {<br />        strings.Sort();<br />        <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(0,0,255)">string</span>&gt; results = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(0,0,255)">string</span>&gt;();<br />        <span style="color: rgb(0,0,255)">foreach</span> (<span style="color: rgb(0,0,255)">var</span> s <span style="color: rgb(0,0,255)">in</span> strings)<br />        {<br />            <span style="color: rgb(0,0,255)">var</span> words = s.Split(<span style="color: rgb(163,21,21)">' '</span>);<br />            <span style="color: rgb(0,0,255)">var</span> wordCount = 0;<br />            <span style="color: rgb(0,0,255)">foreach</span> (<span style="color: rgb(0,0,255)">var</span> word <span style="color: rgb(0,0,255)">in</span> words)<br />            {<br />                <span style="color: rgb(0,0,255)">if</span> (word.Equals(<span style="color: rgb(163,21,21)">"it"</span>, <span style="color: rgb(43,145,175)">StringComparison</span>.CurrentCultureIgnoreCase))<br />                {<br />                    wordCount++;<br />                }<br />            }<br />            results.Add(<span style="color: rgb(43,145,175)">String</span>.Format(<span style="color: rgb(163,21,21)">"[{0}] {1}"</span>, wordCount, s));<br />        }<br />        <span style="color: rgb(0,0,255)">return</span> results;<br />    }<br />}</pre><br /><p>Let’s see what’s happening here.&nbsp; We start by doing a Sort() on our initial list, then we iterate over that list.&nbsp; For each string in the list we break it down into its words using the Split() method and iterate over the resulting words looking for “it” occurrences.&nbsp; Note that we do the comparison in a case-insensitive manner.</p><br /><p>Finally we take our “it” count and the original string and combine them using a String.Format() call, placing the result in the results list.</p><br /><p>A quick look at this code and you might say that it’s decent code.&nbsp; Admittedly it has a nested foreach loop and there’s an if statement stuck inside the innermost loop, but it’s overall it’s not too bad.</p><br /><p>If we were to use a tool like SourceMonitor to get the metrics for the code block we’d see that it has a cyclomatic complexity of 4.&nbsp; Probably about as good as we can get while still maintaining readability.</p><br /><h4>A .NET 3.5 Implementation</h4><br /><p>What we now want to do is try and put this together using LINQ and extension methods and see how it would look then.</p><br /><p>For those who don’t know, an <em>extension method</em> is a way of writing code that adds new functionality to existing classes without needing to actually get into those classes and change them.</p><br /><p>Before we go there however, we first need to change the test to figure out what we want our code to behave like.&nbsp; Let’s take the original test and just change the two lines that create the string list and call the SortAndPrefix() method to one line like so:</p><pre class="code"><span style="color: rgb(0,0,255)">var</span> result = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(0,0,255)">string</span>&gt; { s1, s2, s3, s4 }.SortAndPrefix();</pre><br /><p>We’re going to use an extension method here.&nbsp; We’re taking the List&lt;string&gt; class and going to extend it by adding a method called SortAndPrefix() to it.&nbsp;&nbsp; It means we can save a line of code that is used solely to pass an object to the next line and instead combine the creation of the List&lt;&gt; and the method call into a single statement.</p><br /><p>Let’s have a look at how we might code this using .NET 3.5, LINQ and Extension methods:</p><pre class="code"><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">LinqSorter<br /></span>{<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(0,0,255)">string</span>&gt; SortAndPrefix(<span style="color: rgb(0,0,255)">this</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(0,0,255)">string</span>&gt; strings)<br />    {<br />        <span style="color: rgb(0,0,255)">return</span> (<span style="color: rgb(0,0,255)">from</span> s <span style="color: rgb(0,0,255)">in</span> strings<br />                <span style="color: rgb(0,0,255)">orderby</span> s<br />                <span style="color: rgb(0,0,255)">select</span> s.Prefixed()).ToList();<br />    }<br /><br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">string</span> Prefixed(<span style="color: rgb(0,0,255)">this</span> <span style="color: rgb(0,0,255)">string</span> s)<br />    {<br />        <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(43,145,175)">String</span>.Format(<span style="color: rgb(163,21,21)">"[{0}] {1}"<br /></span>             , s.Split().Count(w =&gt; w.Equals(<span style="color: rgb(163,21,21)">"it"</span><br />                           , <span style="color: rgb(43,145,175)">StringComparison</span>.CurrentCultureIgnoreCase))<br />             , s);<br />    }<br />}<br /></pre><a href="http://11011.net/software/vspaste"></a><br /><p>&nbsp;</p><br /><h4>SortAndPrefix()</h4><br /><p>The SortAndPrefix() method is an extension method.&nbsp; An extension method has two obvious characteristics:&nbsp; First it’s a static method on a static class, and secondly the first parameter has the keyword “this” before the type identifier.&nbsp; The “this” tells the compiler what class the extension method should be attached to.</p><br /><p>In this case the SortAndPrefix() method is applied to objects of type List&lt;string&gt;, which is what we wanted to use in our unit test.</p><br /><p>The next part of the method is the LINQ statement itself.</p><br /><p>Let’s break it down a little to make it easier to understand:</p><br /><p>1. "from s in strings”.&nbsp; We’re processing the List&lt;&gt; and for each string in the list assigning it to the variable “s'”.&nbsp; This is equivalent to the “foreach (var s in strings)” from .NET 2.0</p><br /><p>2. “orderby s” very simply ensures that the order strings are returned in are in alphabetical order.</p><br /><p>3. “select s.Prefixed()”&nbsp; This calls the Prefixed() method on each string – see below - to the strings selected by the LINQ query and returns the result of that method instead of just the unprocessed strings themselves.</p><br /><p>4. “.ToList()”.&nbsp; Executes the query and returns the results as a list to the caller.</p><br /><p>Now there’s a few things to be aware of here.&nbsp; LINQ queries are just query definitions, not the results themselves and a query definition does nothing until a “closure” is used on it.&nbsp; A closure is simply a method that wants to do something with the results the LINQ query will return.&nbsp; So when LINQ sees a closure it takes the query definition, processes it and passes the results to the closure method.&nbsp; You can think of this a little like ADO.NET where you can write a SQL statement in your code, but until you call a data reader to actually get the statement processed nothing happens.</p><br /><p>In our case LINQ the query is executed when the ToList() method is called.</p><br /><p>Obviously, the results of the query are returned to the caller as a List&lt;&gt;.</p><br /><h4>Prefixed()</h4><br /><p>The Prefixed() extension method (yes, we’re using a second extension method) simply takes a string and counts the words in it – once again, using a LINQ query.</p><br /><p>This time we take the string and split it into its components and then counts the “it” words in it.&nbsp; Interestingly the way the counting is done is by supplying a lambda expression to the Count() method.</p><br /><p>Lambdas aren’t anything complex, they are just methods defined in line instead of elsewhere in the code, and since they are inline, they don’t need a name (they are sometimes called anonymous methods).</p><br /><p>The “=&gt;” operator simply defines the parameter names for the method on the left and the method body on the right.&nbsp; So if we had to read aloud the statement in the Prefixed() method we might say something like the following:</p><br /><p>Take a string “s” and Split() it to get an array of strings containing the “words” from s. Next get a count of “it” words by processing the words as follows: Each word is passed in as a parameter “w” to a method that checks if w is the word “it”. if the comparison returns true then the word is counted.</p><br /><h4>Wrap Up</h4><br /><p>Now technically there is no need to use two extension methods.&nbsp; We could have just put all the code from the Prefixed() method in the “select” clause of the SortAndPrefix() method and everything would have worked just as well.&nbsp; However, by splitting it out we improve the readability of the code and improve it’s maintainability.</p><br /><p>If we look at the metrics and run SourceMonitor over our code base, we find that we now have a total complexity of 2, with each method having a complexity of 1,&nbsp; and there are a total of 2 statements.&nbsp; It’s certainly more concise and less nested than the foreach version of the code.</p><br /><p>By the way, Visual Studio does metric analysis at the IL level and will produce different results, especially where LINQ and foreach operators are concerned as these constructs actually wrap a number of behind the scenes calls.</p><br /><h4>Conclusion</h4><br /><p>Hopefully that has given you an idea of how LINQ and Extension methods work (at least at a basic level) and shows you how you can improve your existing code to make it easier to read and more maintainable.</p><br /><p>If you’ve got any questions, please feel free to ask.</p>  