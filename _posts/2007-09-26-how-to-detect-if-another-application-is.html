---
layout: post
title: How To Detect if Another Application is Running in Full Screen Mode
date: '2007-09-26T18:37:00.001+10:00'
author: Richard Banks
tags:
- readify
- ".net"
- development
modified_time: '2007-09-26T18:37:29.944+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-2319570013450909430
blogger_orig_url: http://www.richard-banks.org/2007/09/how-to-detect-if-another-application-is.html
---

<p>Recently I wrote a system tray application in C# that displayed reminders for people at regular intervals. What I wanted to avoid was displaying reminders when another application was running in full screen mode.&nbsp; For example if PowerPoint was showing a presentation or there was a full screen video running the last thing I wanted was an annoying message to come up and bug people.</p> <p>A quick search on Google showed that there isn't a lot of useful information on how to tell if another program is running in full screen, so it took me a little while to figure it out, but In the end it worked out to be a pretty simple check.</p> <p>The steps involved are as follows</p> <ol> <li>Get the window handle for the current application.&nbsp; I assume that if someone is running a full screen application, it's going to be the active application.  <li>Get the size of the display on which it is being shown.&nbsp; Using the primary display is not appropriate if multiple displays are involved.  <li>Compare the size of the application and the size of the display.&nbsp; If they match, it's in full screen mode.</li></ol> <p>There is a catch, however.&nbsp; If the user is navigating the programs menu, using ALT+TAB, showing the desktop or they have just closed an application and nothing else will have focus.&nbsp; In these situations the current application is going to be either the desktop or the windows shell (progman) and both of those windows are full screen windows.&nbsp; If that's the case we still want to show messages.</p> <p>OK, so let's break down the code.</p> <p>First up, we need to declare a few methods so that we can query the operating system for window handles and information: </p><pre class="codeblock"><span style="color: rgb(0,0,255)">using</span> System.Runtime.InteropServices;<br />[<span style="color: rgb(43,145,175)">StructLayout</span>(<span style="color: rgb(43,145,175)">LayoutKind</span>.Sequential)]<br /><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">struct</span> <span style="color: rgb(43,145,175)">RECT<br /></span>{<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">int</span> Left;<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">int</span> Top;<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">int</span> Right;<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">int</span> Bottom;<br />}<br /><br /><span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">MyClass</span><span style="color: rgb(43,145,175)"><br /></span>{<br />    [<span style="color: rgb(43,145,175)">DllImport</span>(<span style="color: rgb(163,21,21)">"user32.dll"</span>)]<br />    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">extern</span> <span style="color: rgb(43,145,175)">IntPtr</span> GetForegroundWindow();<br />    [<span style="color: rgb(43,145,175)">DllImport</span>(<span style="color: rgb(163,21,21)">"user32.dll"</span>)]<br />    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">extern</span> <span style="color: rgb(43,145,175)">IntPtr</span> GetDesktopWindow();<br />    [<span style="color: rgb(43,145,175)">DllImport</span>(<span style="color: rgb(163,21,21)">"user32.dll"</span>)]<br />    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">extern</span> <span style="color: rgb(43,145,175)">IntPtr</span> GetShellWindow();<br />    [<span style="color: rgb(43,145,175)">DllImport</span>(<span style="color: rgb(163,21,21)">"user32.dll"</span>, SetLastError = <span style="color: rgb(0,0,255)">true</span>)]<br />    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">extern</span> <span style="color: rgb(0,0,255)">int</span> GetWindowRect(<span style="color: rgb(43,145,175)">IntPtr</span> hwnd, <span style="color: rgb(0,0,255)">out</span> <span style="color: rgb(43,145,175)">RECT</span> rc);</pre><br /><p>GetForegroundWindow returns a handle for the currently active window, GetDesktopWindow returns a handle for the desktop and GetShellWindow returns the handle for the windows shell.</p><br /><p>GetWindowRect returns the size of a window specified by a particular handle.&nbsp; Note that I've created a specific RECT class for this call.&nbsp; This is because the .NET Rectangle class has a different structure to the RECT class used by the GetWindowRect method.</p><br /><p>Now when we run this program the window handles for the Shell and the Desktop aren't going to change (unless something nasty happens to the shell of course!) so we can just call the GetDesktopWindow and GetShellWindow methods during application startup: </p><pre class="codeblock">    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">IntPtr</span> desktopHandle; <span style="color: rgb(0,128,0)">//Window handle for the desktop<br /></span>    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">IntPtr</span> shellHandle; <span style="color: rgb(0,128,0)">//Window handle for the shell</span><br />    <span style="color: rgb(0,128,0)">//Get the handles for the desktop and shell now.<br /></span>    desktopHandle = GetDesktopWindow();<br />    shellHandle = GetShellWindow();</pre><br /><p>Now whenever we want to show the message window we just need to check if any full screen applications are running as follows:</p><pre class="codeblock">    <span style="color: rgb(0,128,0)">//Detect if the current app is running in full screen<br /></span>    <span style="color: rgb(0,0,255)">bool</span> runningFullScreen = <span style="color: rgb(0,0,255)">false</span>;<br />    <span style="color: rgb(43,145,175)">RECT</span> appBounds;<br />    <span style="color: rgb(43,145,175)">Rectangle</span> screenBounds;<br />    <span style="color: rgb(43,145,175)">IntPtr</span> hWnd;<br /><br />    <span style="color: rgb(0,128,0)">//get the dimensions of the active window<br /></span>    hWnd = GetForegroundWindow();<br />    <span style="color: rgb(0,0,255)">if</span> (hWnd!=<span style="color: rgb(0,0,255)">null</span> &amp;&amp; !hWnd.Equals(<span style="color: rgb(43,145,175)">IntPtr</span>.Zero))<br />    {<br />        <span style="color: rgb(0,128,0)">//Check we haven't picked up the desktop or the shell<br /></span>        <span style="color: rgb(0,0,255)">if</span> (!(hWnd.Equals(desktopHandle) || hWnd.Equals(shellHandle)))<br />        {<br />            GetWindowRect(hWnd, <span style="color: rgb(0,0,255)">out</span> appBounds);<br />            <span style="color: rgb(0,128,0)">//determine if window is fullscreen<br /></span>            screenBounds = <span style="color: rgb(43,145,175)">Screen</span>.FromHandle(hWnd).Bounds;<br />            <span style="color: rgb(0,0,255)">if</span> ((appBounds.Bottom - appBounds.Top) == screenBounds.Height &amp;&amp; (appBounds.Right - appBounds.Left) == screenBounds.Width)<br />            {<br />                runningFullScreen = <span style="color: rgb(0,0,255)">true</span>;<br />            }<br />        }<br />    }</pre><br /><p>So, first we get the handle (hWnd) of the current foreground window using GetForegroundWindow().&nbsp; It's possible that this method can return null, so we'll check it just in case.</p><br /><p>We then check if the handle we retrieved is the handle for either the shell or the desktop.&nbsp; if it is, then we skip the other checks.</p><br /><p>Next we call GetWindowRect and to get the top-left and bottom-right corners of the window.&nbsp; We also determine what display the application is running on and get the full size of the display.&nbsp; The full size is inclusive of any taskbars, sidebars or other windows that chew up the normal screen real estate.</p>Then it's just a simple check to see if the dimensions are the same, set a flag, and we're done. 