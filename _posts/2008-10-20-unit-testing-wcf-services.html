---
layout: post
title: Unit Testing WCF Services
date: '2008-10-20T23:20:00.001+11:00'
author: Richard Banks
tags:
- readify
- ".net"
- testing
- development
modified_time: '2008-10-20T23:20:45.309+11:00'
thumbnail: http://lh6.ggpht.com/rbanks54/SPx3lbTcb2I/AAAAAAAAAlk/gfJ77yW9x-g/s72-c/image_thumb%5B1%5D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-13321238.post-6441789698053203249
blogger_orig_url: http://www.richard-banks.org/2008/10/unit-testing-wcf-services.html
---

<p>I've seen a lot of people test WCF services using integration tests.&nbsp; You know, where you create a small program as a test harness that creates a client for a web service, calls the service and checks what happened.&nbsp; Similarly when you want to test your client side code is using the service properly then you have to have your client talking to something, so you need to have a test service running and that can be a pain at times, especially if the service is hosted somewhere in the cloud.</p> <h4>Testing a WCF Service</h4> <p>Testing WCF services themselves is actually quite straightforward.&nbsp; Since a WCF service library is really just a normal class library it means that WCF services can can actually be called and tested using NUnit, MSTest or your favourite xUnit framework without needing a proper WCF client at all as I'll show you here:</p> <p>Let's start by adding a WCF Service to a service library:</p> <p><a href="http://lh4.ggpht.com/rbanks54/SPx3kST-3fI/AAAAAAAAAlg/-ADx50QABEI/s1600-h/image%5B3%5D.png"><img style="border-right-width: 0px; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" border="0" alt="image" src="http://lh6.ggpht.com/rbanks54/SPx3lbTcb2I/AAAAAAAAAlk/gfJ77yW9x-g/image_thumb%5B1%5D.png?imgmax=800" width="630" height="356"></a> </p> <p>When we do, we get two new files added to our project - MyService.cs and IMyService.cs.</p> <p>MyService.cs is just a simple skeleton as shown here:</p><pre class="codeblock"><span style="color: rgb(0,0,255)">namespace</span> WcfServiceLibrary1<br />{<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">MyService</span> : <span style="color: rgb(43,145,175)">IMyService<br /></span>    {<br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> DoWork()<br />        {<br />        }<br />    }<br />}</pre><br /><p>The interface likewise is also very simple:</p><pre class="codeblock"><span style="color: rgb(0,0,255)">namespace</span> WcfServiceLibrary1<br />{<br />    [<span style="color: rgb(43,145,175)">ServiceContract</span>]<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">interface</span> <span style="color: rgb(43,145,175)">IMyService<br /></span>    {<br />        [<span style="color: rgb(43,145,175)">OperationContract</span>]<br />        <span style="color: rgb(0,0,255)">void </span>DoWork();<br />    }<br />}</pre><br /><p>Nothing to it.&nbsp; So let's implement something simple so that we at least have something to test :-)&nbsp; How about we change DoWork() to return an int with the current hour of the day and update the interface definition to match.&nbsp; Something like this:</p><pre class="codeblock">        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">int</span> DoWork()<br />        {<br />            <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(43,145,175)">DateTime</span>.Now.Hour;<br />        }</pre><br /><p>Now, being good programmers, we want to make sure our incredibly complex method works as expected so let's write a test for it.&nbsp; Remembering that the MyService class is just a normal class we don't actually need to do anything via WCF at all.&nbsp; Just test it like so:</p><pre class="codeblock">        [<span style="color: rgb(43,145,175)">TestMethod</span>()]<br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> DoWorkTest()<br />        {<br />            <span style="color: rgb(43,145,175)">MyService</span> target = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">MyService</span>();<br />            <span style="color: rgb(0,0,255)">int</span> expected = <span style="color: rgb(43,145,175)">DateTime</span>.Now.Hour;<br />            <span style="color: rgb(43,145,175)">Assert</span>.AreEqual(expected, target.DoWork());<br />        }</pre><br /><p>I know the example is a little too simplistic, but you should get the idea.</p><br /><h4>Testing a WCF Client</h4><br /><p>So now that we have a working service how do call it?&nbsp; And how do we test our client?&nbsp; Now when we add a WCF service reference in our client project Visual Studio will generate the code for a WCF service client - it's this service client that our application will use, so is there any value in testing the client generated by Visual Studio itself?&nbsp; Probably not.&nbsp; So the question then becomes: how do we test that the WCF service client is being used correctly by our application code.</p><br /><p>Let's start an example by adding a service reference to our WCF Service we created above, similar to what's shown here.&nbsp; This is what we'll use in our client application.</p><br /><p><a href="http://lh6.ggpht.com/rbanks54/SPx3mDVJcYI/AAAAAAAAAlo/00Uh4aTzaco/s1600-h/image%5B6%5D.png"><img style="border-right-width: 0px; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" border="0" alt="image" src="http://lh3.ggpht.com/rbanks54/SPx3nMXKnZI/AAAAAAAAAls/CnlDYkRnoyk/image_thumb%5B2%5D.png?imgmax=800" width="600" height="484"></a></p><br /><p>Visual Studio goes ahead and adds the reference to the solution and behind the scenes creates a MyServiceClient class that we can then call from our application as shown in the following code:</p><pre class="codeblock">        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">string</span> CallMyServiceClient()<br />        {<br />            <span style="color: rgb(0,0,255)">int</span> result;<br />            <span style="color: rgb(43,145,175)">MyServiceClient</span> client = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">MyServiceClient</span>();<br />            result = client.DoWork();<br />            <span style="color: rgb(0,0,255)">return</span> result.ToString();<br />        }</pre><br /><p>Code like the above is something you will see in many places around the web, however we have just made life a lot harder for ourselves than we need to.&nbsp; Can you see the problem?&nbsp; If I want to test the CallMyServiceClient method I have to instantiate a WCF client and call it, which also means I also have to have a WCF service running and ensure all my WCF end points are configured correctly for the test environment.&nbsp; It's OK when it's a simple like this, but in a large application with many services and people involved this sort of thing can get out of hand very quickly.</p><br /><p>Further, if I wanted some way to see what happens to my code should the service throw an exception I'd have some difficulties so my error handling code (or lack thereof) will usually go largely untested.</p><br /><p>Thankfully there are a few simple changes we can make to make this testability problem go away.</p><br /><p>First, have a look at the declaration of the MyServiceClient and you'll see that Visual Studio has generated something like this:</p><pre class="codeblock">    [System.Diagnostics.<span style="color: rgb(43,145,175)">DebuggerStepThroughAttribute</span>()]<br />    [System.CodeDom.Compiler.<span style="color: rgb(43,145,175)">GeneratedCodeAttribute</span>(<span style="color: rgb(163,21,21)">"System.ServiceModel"</span>, <span style="color: rgb(163,21,21)">"3.0.0.0"</span>)]<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">partial</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">MyServiceClient</span> : <br />        System.ServiceModel.<span style="color: rgb(43,145,175)">ClientBase</span>&lt;WCFClientLibrary1.MyServiceReference.<span style="color: rgb(43,145,175)">IMyService</span>&gt;<br />        , WCFClientLibrary1.MyServiceReference.<span style="color: rgb(43,145,175)">IMyService</span> {<br />        <br />        <span style="color: rgb(0,0,255)">public</span> MyServiceClient() {<br />        }</pre><br /><p>The interesting thing to note here is that MyServiceClient is implementing the IMyService interface.&nbsp; So if we wanted we could remove the concrete class reference and use the interface like so:</p><pre class="codeblock">        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">string</span> CallMyServiceClient()<br />        {<br />            <span style="color: rgb(0,0,255)">int</span> result;<br />            <span style="color: rgb(43,145,175)"><strong>IMyService</strong></span> client = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">MyServiceClient</span>();<br />            result = client.DoWork();<br />            <span style="color: rgb(0,0,255)">return</span> result.ToString();<br />        }</pre><br /><p>But this doesn't help much since we still have that instantiation of the MyServiceClient in our method to deal with.&nbsp; We need to get that out of there.&nbsp; To do that we'll use Dependency Injection - a technique where instead of the class creating the dependencies it needs, we pass into the class everything else that the class has a dependency on - in this case the MyServiceClient class.&nbsp; Here's how we could do it:</p><pre class="codeblock">    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">MyClass<br /></span>    {<br />        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">IMyService</span> client;<br /><br />        <span style="color: rgb(0,0,255)">public</span> MyClass(<span style="color: rgb(43,145,175)">IMyService</span> wcfClient)<br />        {<br />            client = wcfClient;<br />        }<br /><br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">string</span> CallMyServiceClient()<br />        {<br />            <span style="color: rgb(0,0,255)">int</span> result = client.DoWork();<br />            <span style="color: rgb(0,0,255)">return</span> result.ToString();<br />        }</pre><br /><p>So now when we create an instance of MyClass we pass in an instance of the MyServiceClient class so that MyClass doesn't have to create a reference to MyServiceClient.&nbsp; We could do this either through our own application code higher up the call stack or through the use of an Inversion of Control container such as Unity, Castle Windsor or any of the other choices out there.</p><br /><p>Now that we've introduced dependency injection we have also given ourselves a way to test MyClass without actually hitting the WCF service client at all.</p><br /><p>What we need to do is to create a fake version of the MyServiceClient class that we can use as a substitute for the real WCF service client and pass that to MyClass instead.&nbsp; We could, if we chose, create this fake class ourselves, but mocking frameworks exist to make our life easier in the regard and come with a bunch of extra features that let us do things such as setting return values when calls are made, without us having to write that ourselves.</p><br /><p>Here's a test we might use with our client using the Rhino Mocks framework:</p><pre class="codeblock">        [<span style="color: rgb(43,145,175)">TestMethod</span>()]<br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> ClientTest()<br />        {<br />            <span style="color: rgb(43,145,175)">IMyService</span> mock = <span style="color: rgb(43,145,175)">MockRepository</span>.GenerateMock&lt;<span style="color: rgb(43,145,175)">IMyService</span>&gt;();<br />            mock.Expect(t =&gt; t.DoWork()).Return(10);<br /><br />            <span style="color: rgb(43,145,175)">MyClass</span> classUnderTest = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">MyClass</span>(mock);<br />    <br />            <span style="color: rgb(43,145,175)">Assert</span>.AreEqual(<span style="color: rgb(163,21,21)">"10"</span>, classUnderTest.CallMyServiceClient());<br />            mock.VerifyAllExpectations();<br />        }</pre><br /><p>Let's have a look at this test in a little more detail.&nbsp; What are we doing here?</p><br /><ol><br /><li>We're creating a fake version of the IMyService class called "mock". <br /><li>We then tell the mock object to return the value 10 when its DoWork method is called. <br /><li>Next we create a MyClass instance and pass the fake class through to it in place of a real WCF service client. <br /><li>Then we call our classUnderTest and assert that the method returned the expected value <br /><li>And on the last line we also check that the DoWork() method was called on our mock object (i.e. we didn't just return from MyClass without calling the IMyService method)</li></ol><br /><p>This is quite useful as we now have a way to test our application code is making the appropriate calls to the WCF client without needing to actually spin up a full WCF client &amp; service nor do we have to do any testing across the wire.&nbsp; This example is also simple enough to extend so that when the DoWork() method is called we can throw a WCF exception instead to test how well our class handles failures.</p><br /><p>I hope this helps you improve your testing with WCF in the future.&nbsp; Good luck!</p>  