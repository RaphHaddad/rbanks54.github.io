---
layout: post
title: 'Mocking Comparison – Part 4: Parameter Constraints'
date: '2010-07-22T16:45:00.001+10:00'
author: Richard Banks
tags:
- mocking
modified_time: '2010-08-06T08:54:54.126+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-1223175520250091180
blogger_orig_url: http://www.richard-banks.org/2010/07/mocking-comparison-part-4-parameter.html
---

<p>Continuing with our comparison of Rhino Mocks, Moq and NSubstitute we now turn our eye to how constraints are managed.</p>  <p>Consider a method with parameters that was want to mock.&#160; By default, a mock object will only return a specified value if the parameters passed to it exactly match the call signature specified to the mock object.&#160; Maybe that’s a bit wordy, so as a quick example if you say Method(“a”).Returns(“Fred”) you’ll only get “Fred” back from the mock when you pass “a” as the parameter.&#160; Passing “b” gets you nothing. Make sense?</p>  <p>OK, so what if I then want my mock object to provide different return values when different parameter values are used.&#160; How do we avoid writing too much code or having to work out exactly what we should expect as a parameter every time?&#160; And what if I don’t care what’s passed in, I just want a return value.</p>  <p>This is where constraints come into play.&#160; Let’s look at some code to show how it works:</p>  <h3>Rhino Mocks</h3>  <p>Here’s a test where we try to add fleas to our monkey.&#160; Adding positive numbers of fleas should succeed and adding a negative number of fleas should fail.</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:77ae5b8e-5f92-442e-ae7a-8ad509c9137b" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Rhino_no_constraints()<br />{<br /> var monkey = MockRepository.GenerateMock&lt;IMonkey&gt;();<br /> monkey.Stub(m =&gt; m.TryAddFleas(5)).Return(true);<br /> monkey.Stub(m =&gt; m.TryAddFleas(-1)).Return(false);<br /> monkey.Stub(m =&gt; m.TryAddFleas(9)).Return(true);<br /><br /> Assert.Equal(true, monkey.TryAddFleas(5));<br /> Assert.Equal(false, monkey.TryAddFleas(-1));<br /> Assert.Equal(true, monkey.TryAddFleas(9));<br />}</pre></div><p>Notice how the use of explicit parameter values in the stubs means we have to repeat a lot of code.&#160; Hmm, that’s annoying.</p><p>Thankfully we can simplify this by just ignoring the arguments as seen in the code below.&#160; Note that we still have to supply a parameter value for the TryAddFleas lambda in the Stub call, even though it’s ignored.</p><div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:ab477b0c-7142-44d3-bf50-a3bfbc180ce2" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Rhino_ignore_arguments()<br />{<br /> var monkey = MockRepository.GenerateMock&lt;IMonkey&gt;();<br /> monkey.Stub(m =&gt; m.TryAddFleas(0)).IgnoreArguments().Return(true);<br /><br /> Assert.Equal(true, monkey.TryAddFleas(5));<br /> Assert.Equal(false, monkey.TryAddFleas(-1));<br /> Assert.Equal(true, monkey.TryAddFleas(9));<br />}</pre></div><p>However this will now cause the test to fail because we no longer return a false when passed -1 as a value.</p><p>So what we really want is to only return true when the argument value is in a certain range.&#160; For fun let’s make that range between 4 and 9 inclusive.&#160; Here’s the test now, using constraints:</p><div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:8913c4e6-9cee-48c7-ada5-b90683d33fd2" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Rhino_constraints()<br />{<br /> var monkey = MockRepository.GenerateMock&lt;IMonkey&gt;();<br /><br /> monkey.Stub(m =&gt; m.TryAddFleas(0))<br />  .Constraints(Is.LessThan(10) &amp;&amp; Is.GreaterThan(3))<br />  .Return(true);<br /> Assert.Equal(true, monkey.TryAddFleas(5));<br /> Assert.Equal(false, monkey.TryAddFleas(-1));<br /> Assert.Equal(true, monkey.TryAddFleas(9));<br />}</pre></div><p>Whilst this means I have 2 less Stub calls to make, it does tend to be a little verbose.&#160; Expressive, but verbose.&#160; For those wondering why I don’t have a constraint for the -1 argument, I’m relying on the standard behaviour of mocks.&#160; If a constraint isn’t matched then the standard mock behaviour is to return the default value of the return type, being false in this case.</p><h3>Moq</h3><p>Here’s the same thing in Moq.&#160; For brevity and completeness I’ve included a commented out line that shows what you would do if you just wanted to ignore parameter values</p><div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:51a29e56-920e-48e2-a588-adb512315132" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Moq_constraints()<br />{<br /> var monkey = new Mock&lt;IMonkey&gt;();<br /><br /> //monkey.Setup(m =&gt; m.TryAddFleas(It.IsAny&lt;int&gt;())).Returns(true);<br /> monkey.Setup(m =&gt; m.TryAddFleas(It.IsInRange(3, 10, Range.Exclusive)))<br />  .Returns(true);<br /> Assert.Equal(true, monkey.Object.TryAddFleas(5));<br /> Assert.Equal(false, monkey.Object.TryAddFleas(-1));<br /> Assert.Equal(true, monkey.Object.TryAddFleas(9));<br />}</pre></div><p>The IsInRange method is quite nice, and the range constraints can be either inclusive or exclusive, however the code feels as verbose if not more so than the Rhino approach.</p><p>Note that if you use a test harness like MSpec (Machine.Specifications) then the “It” static class that Moq uses clashes with the “It” class used by MSpec for defining specifications which makes writing code a little painful at times.</p><h3>NSubstitute</h3><p>Finally the NSubstitute version.</p><div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:60266510-d85f-4174-9663-15f94ce0ac57" class="wlWriterEditableSmartContent"><pre class="brush: c#;">[Fact]<br />public void Nsubtitute_constraints()<br />{<br /> var monkey = Substitute.For&lt;IMonkey&gt;();<br /><br /> //monkey.TryAddFleas(Arg.Any&lt;int&gt;()).Returns(true);<br /> monkey.TryAddFleas(Arg.Is&lt;int&gt;(count =&gt; count &gt; 3 &amp;&amp; count &lt; 10))<br />  .Returns(true);<br /><br /> Assert.Equal(true, monkey.TryAddFleas(5));<br /> Assert.Equal(false, monkey.TryAddFleas(-1));<br /> Assert.Equal(true, monkey.TryAddFleas(9));<br />}</pre></div><p>This works much the same as the others with the difference being that you have a predicate as the parameter and you need to supply the parameter type to the Arg.Is&lt;T&gt; call.</p><p>From a readability perspective, there’s less code which is good and it’s easier to read than the other frameworks because of it’s terseness.&#160; As a bonus, using the Arg.Any&lt;T&gt; call means we can avoid lambdas completely..</p><p>&#160;</p><p>Verdict: I’ll go with the NSubstitute version as my first choice, though it’s more a matter of style choice than anything else. After that I prefer the Moq syntax over Rhino in this case.</p><p>&nbsp;</p><p>Other posts in this series:<ul><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-1-basics.html">1: The Basics</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-2-properties.html">2: Properties</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-3-interactions.html">3: Interactions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-5-repetitions.html">5: Repetitions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-6-multiple.html">6: Multiple Calls</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-7-exceptions.html">7: Exceptions</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-8-recursive.html">8: Recursive Mocks</a></li><li><a href="http://www.richard-banks.org/2010/07/mocking-comparison-part-9-functions.html">9: Functions</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-10-events.html">10: Events</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-11-multiple.html">11: Multiple Interfaces</a></li><li><a href="http://www.richard-banks.org/2010/08/mocking-comparison-part-12-unmockables.html">12: The UnMockables</a></li></ul></p>