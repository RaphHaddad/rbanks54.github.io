---
layout: post
title: Aspect Oriented Programming & INotifyPropertyChanged
date: '2009-02-24T14:24:00.001+11:00'
author: Richard Banks
tags:
- ".net"
- tools
- AOP
- development
modified_time: '2009-02-24T14:24:44.628+11:00'
thumbnail: http://lh4.ggpht.com/_5dD_rBQSs2o/SaNodFEUXZI/AAAAAAAAAn0/xOBRLwoF3Tw/s72-c/image_thumb.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-13321238.post-5361019487928243226
blogger_orig_url: http://www.richard-banks.org/2009/02/aspect-oriented-programming.html
---

<p>Normally when people talk about aspect oriented programming (AOP) and try and provide a sample they typically talk about logging.&nbsp; It’s the easiest example for most people to get their head around and it usually involves minimal code.&nbsp; They might also talk about (but not show) how aspects can be used for security and “so much more”.</p> <p>Well, since logging is hardly an interesting aspect to talk about and there’s “so much more” out there, I started thinking about what some of the more interesting uses for aspects might be, and my mind turned to something we typically do when implementing binding for WPF applications.</p><pre class="code"><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">WithoutAspects</span> : <span style="color: rgb(43,145,175)">INotifyPropertyChanged<br /></span>{<br />    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">int</span> myProperty;<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">int</span> MyProperty<br />    {<br />        <span style="color: rgb(0,0,255)">get<br /></span>        {<br />            <span style="color: rgb(0,0,255)">return</span> myProperty;<br />        }<br />        <span style="color: rgb(0,0,255)">set<br /></span>        {<br />            <span style="color: rgb(0,0,255)">if</span> (<span style="color: rgb(0,0,255)">value</span> != myProperty)<br />            {<br />                myProperty = <span style="color: rgb(0,0,255)">value</span>;<br />                NotifyPropertyChanged(<span style="color: rgb(163,21,21)">"MyProperty"</span>);<br />            }<br />        }<br />    }<br /><br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">event</span> <span style="color: rgb(43,145,175)">PropertyChangedEventHandler</span> PropertyChanged;<br />    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">void</span> NotifyPropertyChanged(<span style="color: rgb(43,145,175)">String</span> info)<br />    {<br />        <span style="color: rgb(0,0,255)">if</span> (PropertyChanged != <span style="color: rgb(0,0,255)">null</span>)<br />        {<br />            PropertyChanged(<span style="color: rgb(0,0,255)">this</span>, <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">PropertyChangedEventArgs</span>(info));<br />        }<br />    }<br />}</pre><br /><p>The properties in particular bug me.&nbsp; After all, we now have C# 3.0’s shortcut syntax it would be nice if we could do something like this:</p><pre class="code">[<span style="color: rgb(43,145,175)">NotifyPropertyChanged</span>]<br /><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">WithAspects<br /></span>{<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">int</span> MyProperty { <span style="color: rgb(0,0,255)">get</span>; <span style="color: rgb(0,0,255)">set</span>; }<br />}</pre><br /><p>Here’s where aspects can really help.&nbsp; Consider the INotifyPropertyChanged implementation and all that binding code that is in our class and think about how it cuts across the purpose of the class itself.&nbsp; This is exactly what aspects can be used to help with.</p><br /><p>If we were to write an aspect that looked for a [NotifyPropertyChanged] attribute on a class and then performed all the work that we are currently hard coding we could then move all that “noise” code out of our class and let the class focus on whatever it is that our class does.</p><br /><p>It makes sense, right? So let’s do it.&nbsp; Let’s write an aspect for INotifyPropertyChanged that does what we want.</p><br /><h3>First, Which Framework Should We Use?</h3><br /><p>So the first question that comes to mind is which AOP framework should we use?&nbsp; Should we use <a href="http://www.castleproject.org/container/index.html" target="_blank">Castle Windsor</a> (or another IoC container), the <a href="http://msdn.microsoft.com/en-us/library/dd139982.aspx" target="_blank">Policy Injection Application Block</a> or <a href="http://www.postsharp.org/" target="_blank">PostSharp</a>?</p><br /><p>Windsor and PIAB both have a shortfall that we can’t overcome.&nbsp; Neither of them can alter the type of a class they are providing aspects for – they simply provide proxies that add hooks to intercept method calls.&nbsp; We would still need to implement INotifyPropertyChanged in our class for binding to work.</p><br /><p>PostSharp on the other hand, applies aspects by altering the compiled code after compilation, meaning that we can create a POCO class and use an aspect to add the INotifyPropertyChanged interface to it.&nbsp; We’ll go with that for now. </p><br /><h3>Disclaimer: This Has Already Been Done (Kind Of)</h3><br /><p>The good news is that there are already examples for doing this out there and in fact a binding aspect is provided as one of the samples in the PostSharp documentation (part of the download).&nbsp; So, instead of pretending I write all this code from scratch I’ll point you to where I got my starting point</p><br /><p><a title="http://thetreeknowseverything.net/2009/01/21/auto-implement-inotifypropertychanged-with-aspects/#" href="http://thetreeknowseverything.net/2009/01/21/auto-implement-inotifypropertychanged-with-aspects/#">http://thetreeknowseverything.net/2009/01/21/auto-implement-inotifypropertychanged-with-aspects/#</a></p><br /><p>OK, so now that you’re back, did you notice a problem with the implementations?&nbsp; Neither of them check the existing value of the property to determine if the PropertyChanged(…) method should be fired, they just fire the event every time someone calls the setter.</p><br /><p>I don’t want to do that, I want only fire the event when the property value change.&nbsp; So, let’s run have a run through the code and see how this can be done.</p><br /><h3>The NotifyPropertyChanged Attribute</h3><br /><p>So first up we need to decorate our class with an attribute that PostSharp can use to know where to do it’s stuff.</p><br /><p>First, we’ll add some references:</p><br /><p><a href="http://lh6.ggpht.com/_5dD_rBQSs2o/SaNocrnAzFI/AAAAAAAAAnw/-ulp6Iykf1E/s1600-h/image2.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://lh4.ggpht.com/_5dD_rBQSs2o/SaNodFEUXZI/AAAAAAAAAn0/xOBRLwoF3Tw/image_thumb.png?imgmax=800" width="193" height="88"></a> </p><br /><p>And then we’ll create the custom attribute.</p><pre class="code">[<span style="color: rgb(43,145,175)">Serializable</span>]<br />[<span style="color: rgb(43,145,175)">AttributeUsage</span>(<span style="color: rgb(43,145,175)">AttributeTargets</span>.Assembly | <span style="color: rgb(43,145,175)">AttributeTargets</span>.Class<br />        , AllowMultiple = <span style="color: rgb(0,0,255)">false</span>, Inherited = <span style="color: rgb(0,0,255)">false</span>)]<br />[<span style="color: rgb(43,145,175)">MulticastAttributeUsage</span>(<span style="color: rgb(43,145,175)">MulticastTargets</span>.Class, AllowMultiple = <span style="color: rgb(0,0,255)">false</span>)]<br /><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">NotifyPropertyChangedAttribute</span> : <span style="color: rgb(43,145,175)">CompoundAspect<br /></span>{<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">int</span> AspectPriority { <span style="color: rgb(0,0,255)">get</span>; <span style="color: rgb(0,0,255)">set</span>; }<br /><br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">override</span> <span style="color: rgb(0,0,255)">void</span> ProvideAspects(<span style="color: rgb(0,0,255)">object</span> element<br />                                      , <span style="color: rgb(43,145,175)">LaosReflectionAspectCollection</span> collection)<br />    {<br />        <span style="color: rgb(43,145,175)">Type</span> type = (<span style="color: rgb(43,145,175)">Type</span>)element;<br /><br />        collection.AddAspect(type, <br />                <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">PropertyChangedAspect</span> { AspectPriority = AspectPriority });<br /><br />        <span style="color: rgb(0,0,255)">foreach</span> (<span style="color: rgb(43,145,175)">PropertyInfo</span> propertyInfo <br />            <span style="color: rgb(0,0,255)">in</span> type.GetProperties(<span style="color: rgb(43,145,175)">BindingFlags</span>.Public | <span style="color: rgb(43,145,175)">BindingFlags</span>.Instance)<br />            .Where(pi =&gt; pi.GetGetMethod() != <span style="color: rgb(0,0,255)">null</span> &amp;&amp; pi.GetSetMethod() != <span style="color: rgb(0,0,255)">null</span>))<br />        {<br />            collection.AddAspect(propertyInfo.GetSetMethod(),<br />                <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">NotifyPropertyChangedAspect</span>(propertyInfo.Name<br />                        , propertyInfo.PropertyType<br />                        , propertyInfo.DeclaringType) <br />                            { AspectPriority = AspectPriority });<br />        }<br />    }<br />}</pre><br /><p>Notice that this attribute inherits from the CompondAspect class – this is a PostSharp class used to provide developers with more control over how aspects are applied.&nbsp; We’re doing this by providing an implementation of the ProvideAspects method.</p><br /><p>As you can see, when the ProvideAspects method is called we create a new aspect called PropertyChangedAspect and apply it to the class.&nbsp; We then run through all the properties on the class, checking that the have both a setter and a getter.&nbsp; If they do we then create a new NotifyPropertyChangedAspect (written by us) to each of the setters.</p><br /><p>What’s in the PropertyChangedAspect and the NotifyChangedAspect? Well, this is where it gets interesting.</p><br /><h3>The PropertyChangedAspect</h3><br /><p>This is an aspect we want to apply at the class level.&nbsp; It’s here that we want to do what it is we need to in order to ensure that the class implements the INotifyPropertyChanged interface,</p><br /><p>Now because we’re using aspects we still need to ensure that we have an implementation of INotifyPropertyChanged somewhere in our codebase.&nbsp; We could get fancy and use Emit to generate something, but there’s no real benefit in doing so.</p><br /><p>You’ll also note that the implementation is using a slightly different interface (it still inherits from INotifyPropertyChanged) because we want to be able to call NotifyChanged using a PropertyInfo object as well as using the name of the property.</p><pre class="code"><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">interface</span> <span style="color: rgb(43,145,175)">IPropertyChanged</span> : <span style="color: rgb(43,145,175)">INotifyPropertyChanged<br /></span>{<br />    <span style="color: rgb(0,0,255)">void</span> NotifyChanged(<span style="color: rgb(0,0,255)">string</span> propertyName);<br />    <span style="color: rgb(0,0,255)">void</span> NotifyChanged(<span style="color: rgb(43,145,175)">PropertyInfo</span> property);<br />}<br /><br />[<span style="color: rgb(43,145,175)">Serializable</span>]<br /><span style="color: rgb(0,0,255)">internal</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">PropertyChangedImplementation</span> : <span style="color: rgb(43,145,175)">IPropertyChanged<br /></span>{<br />    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">readonly</span> <span style="color: rgb(0,0,255)">object</span> instance;<br /><br />    <span style="color: rgb(0,0,255)">public</span> PropertyChangedImplementation(<span style="color: rgb(0,0,255)">object</span> instance)<br />    {<br />        <span style="color: rgb(0,0,255)">if</span> (instance == <span style="color: rgb(0,0,255)">null</span>)<br />            <span style="color: rgb(0,0,255)">throw</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">ArgumentNullException</span>(<span style="color: rgb(163,21,21)">"instance"</span>);<br /><br />        <span style="color: rgb(0,0,255)">this</span>.instance = instance;<br />    }<br /><br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">event</span> <span style="color: rgb(43,145,175)">PropertyChangedEventHandler</span> PropertyChanged;<br /><br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> NotifyChanged(<span style="color: rgb(0,0,255)">string</span> propertyName)<br />    {<br />        <span style="color: rgb(0,0,255)">if</span> (<span style="color: rgb(0,0,255)">string</span>.IsNullOrEmpty(propertyName))<br />            <span style="color: rgb(0,0,255)">throw</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">ArgumentNullException</span>(<span style="color: rgb(163,21,21)">"propertyName"</span>);<br /><br />        <span style="color: rgb(43,145,175)">PropertyChangedEventHandler</span> eventHandler = PropertyChanged;<br />        <span style="color: rgb(0,0,255)">if</span> (eventHandler != <span style="color: rgb(0,0,255)">null</span>)<br />            eventHandler(instance, <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">PropertyChangedEventArgs</span>(propertyName));<br />    }<br /><br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> NotifyChanged(<span style="color: rgb(43,145,175)">PropertyInfo</span> property)<br />    {<br />        <span style="color: rgb(0,0,255)">if</span> (property == <span style="color: rgb(0,0,255)">null</span>)<br />            <span style="color: rgb(0,0,255)">throw</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">ArgumentNullException</span>(<span style="color: rgb(163,21,21)">"property"</span>);<br /><br />        NotifyChanged(property.Name);<br />    }<br />}</pre><br /><p>Here you can see the NotifyChanged implementation looks much the same as in our original class, though our original class actually forgot to check if the passed in string was null.</p><br /><p>So now that we have that in place, let’s implement our PropertyChanged aspect.&nbsp; We can see here that this aspect is a CompositionAspect. The PostSharp docs describe it as follows: <em>The <code>Composition</code> aspect injects new interfaces into an existing type and defers the implementation of these interfaces to another object that implements them.</em></p><br /><p>What that means is that we can combine our PropertyChangedImplementation class with any other class we like, as long as we attach the PropertyChangedAspect to it.&nbsp; Way cool.</p><br /><p>Let’s do just that</p><pre class="code">[<span style="color: rgb(43,145,175)">Serializable</span>]<br /><span style="color: rgb(0,0,255)">internal</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">PropertyChangedAspect</span> : <span style="color: rgb(43,145,175)">CompositionAspect<br /></span>{<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">override</span> <span style="color: rgb(0,0,255)">object</span> CreateImplementationObject<br>                           (<span style="color: rgb(43,145,175)">InstanceBoundLaosEventArgs</span> eventArgs)<br />    {<br />        <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">PropertyChangedImplementation</span>(eventArgs.Instance);<br />    }<br /><br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">override</span> <span style="color: rgb(43,145,175)">Type</span> GetPublicInterface(<span style="color: rgb(43,145,175)">Type</span> containerType)<br />    {<br />        <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(0,0,255)">typeof</span>(<span style="color: rgb(43,145,175)">IPropertyChanged</span>);<br />    }<br /><br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">override</span> <span style="color: rgb(43,145,175)">CompositionAspectOptions</span> GetOptions()<br />    {<br />        <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(43,145,175)">CompositionAspectOptions</span>.GenerateImplementationAccessor;<br />    }<br />}</pre><br /><p>OK, so now we’ve accomplished most of what we need.&nbsp; We’ve taken our class without any INotifyPropertyChanged interface defined for it, and added that interface to it, as well as providing an implementation of that interface in the class itself by composing it with the PropertyChangedImplementation class.</p><br /><p>We’re not quite done yet – we still need to implement the changed to the properties themselves so that they fire the event when they change.</p><br /><h3>The NotifyPropertyChanged Aspect</h3><br /><p>Remember back in our NotifyPropertyChangedAttribute class that we were attaching the NotifyPropertyChanged aspect to properties in the target class? If you go an look at that code again you’ll see that we have a number of parameters in the constructor we are using.&nbsp; What are they for?</p><br /><p>Let’s have a look:</p><pre class="code">[<span style="color: rgb(43,145,175)">Serializable</span>]<br /><span style="color: rgb(0,0,255)">internal</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">NotifyPropertyChangedAspect</span> : <span style="color: rgb(43,145,175)">OnMethodBoundaryAspect<br /></span>{<br />    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">readonly</span> <span style="color: rgb(0,0,255)">string</span> propertyName;<br />    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">readonly</span> <span style="color: rgb(43,145,175)">Type</span> propertyType;<br />    <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">readonly</span> <span style="color: rgb(43,145,175)">PropertyInfo</span> propertyInfo;<br /><br />    <span style="color: rgb(0,0,255)">public</span> NotifyPropertyChangedAspect(<span style="color: rgb(0,0,255)">string</span> propertyName<br>                 , <span style="color: rgb(43,145,175)">Type</span> propertyType, <span style="color: rgb(43,145,175)">Type</span> classType)<br />    {<br />        <span style="color: rgb(0,0,255)">if</span> (<span style="color: rgb(0,0,255)">string</span>.IsNullOrEmpty(propertyName))<br />            <span style="color: rgb(0,0,255)">throw</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">ArgumentNullException</span>(<span style="color: rgb(163,21,21)">"propertyName"</span>);<br />        <span style="color: rgb(0,0,255)">if</span> (propertyType == <span style="color: rgb(0,0,255)">null</span>)<br />            <span style="color: rgb(0,0,255)">throw</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">ArgumentNullException</span>(<span style="color: rgb(163,21,21)">"propertyType"</span>);<br />        <span style="color: rgb(0,0,255)">if</span> (classType == <span style="color: rgb(0,0,255)">null</span>)<br />            <span style="color: rgb(0,0,255)">throw</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">ArgumentNullException</span>(<span style="color: rgb(163,21,21)">"classType"</span>);<br /><br />        <span style="color: rgb(0,0,255)">this</span>.propertyName = propertyName;<br />        <span style="color: rgb(0,0,255)">this</span>.propertyType = propertyType;<br />        propertyInfo = classType.GetProperty(propertyName);<br />    }</pre><br /><p>So we’re simply storing the property name, the type and getting the reflection PropertyInfo for the property that the aspect is attached to.&nbsp; Why?&nbsp; Because we’re going to be reusing it of course :-)&nbsp; Reflection is slow and we don’t want to do more of it than we need to.</p><br /><p>What you might also notice with this class is that it inherits from the OnMethodBoundaryAspect class.&nbsp; That means that PostSharp will intercept calls to the method and give you the chance to do what you want before making the call.</p><br /><p>Lets do just that – we only want to call our property setter when the value of the property has changed.&nbsp; Since we have an automatic property we need to make that check before the setter gets&nbsp; executed.&nbsp; PostSharp lets you do this by providing an OnEntry method.&nbsp; Let’s implement that method as follows:</p><pre class="code"><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">override</span> <span style="color: rgb(0,0,255)">void</span> OnEntry(<span style="color: rgb(43,145,175)">MethodExecutionEventArgs</span> eventArgs)<br />{<br />    <span style="color: rgb(0,0,255)">var</span> originalValue = <span style="color: rgb(43,145,175)">Convert</span>.ChangeType(<br>            propertyInfo.GetValue(eventArgs.Instance,<span style="color: rgb(0,0,255)">null</span>), propertyType);<br />    <span style="color: rgb(0,0,255)">var</span> newValue = eventArgs.GetReadOnlyArgumentArray()[0];<br />    <span style="color: rgb(0,0,255)">if</span> ((newValue != <span style="color: rgb(0,0,255)">null</span> &amp;&amp; newValue.Equals(originalValue)) <br>          || (newValue == <span style="color: rgb(0,0,255)">null</span> &amp;&amp; originalValue == <span style="color: rgb(0,0,255)">null</span>))<br />    {<br />        eventArgs.FlowBehavior = <span style="color: rgb(43,145,175)">FlowBehavior</span>.Return;<br />    }<br />}</pre><br /><p>So, what’s happening here?</p><br /><p>First, we grab the current value of the property and ensure it is unboxed (the Convert call).<br>Next, we get the new value from the eventArgs parameter and check if it’s null <br>Then we see if the new value is different to the old value. If they’re the same then we set the FlowBehavior to Return so that the actual, real call to the property setter never gets made.</p><br /><p>(P.S. If someone knows reflection better than me, they could probably do a better job of the value comparisons.&nbsp; At least this works)</p><br /><p>So now all that’s left is to call the code to fire the event.&nbsp; PostSharp gives you an OnSuccess method that will get fired when the real method call has completed successfully, so we’ll use that for what we need to do.</p><pre class="code"><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">override</span> <span style="color: rgb(0,0,255)">void</span> OnSuccess(<span style="color: rgb(43,145,175)">MethodExecutionEventArgs</span> eventArgs)<br />{<br />    <span style="color: rgb(0,0,255)">var</span> theObject =<br />    (<span style="color: rgb(43,145,175)">PropertyChangedImplementation</span>)<br />     ((<span style="color: rgb(43,145,175)">IComposed</span>&lt;<span style="color: rgb(43,145,175)">IPropertyChanged</span>&gt;)eventArgs.Instance)<br>          .GetImplementation(eventArgs.InstanceCredentials);<br />    theObject.NotifyChanged(propertyName);<br />}</pre><br /><p>So, what is going on here now? Well, if you remember that the NotifyChanged code is actually implemented in a different class, we need to be able to get to it.&nbsp; Without going into the details at this point (you can read through it in the docs) we simply need to get a hold of the object that has the PropertyChangedImplementation for the object we are targeting.&nbsp; Once we have that, it’s then just a case of calling the NotifyChanged(…) method on it.</p><br /><h3>Some Obvious? Questions</h3><br /><p>OK, so now that we have our aspects implemented and we can tag a POCO class with [NotifyPropertyChanged] and get binding working, what does that change in our code.</p><br /><h4>What happens with the composition of types?</h4><br /><p>How does that effect our coding.&nbsp; Unfortunately because PostSharp does IL weaving after compilation you' won’t get Visual Studio knowing that your POCO class has a PropertyChanged event on it.</p><br /><p>The following test shows how you have to work with things</p><pre class="code">[<span style="color: rgb(43,145,175)">TestMethod</span>]<br /><span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> PropertyChangedEventIsFired()<br />{<br />    <span style="color: rgb(0,0,255)">var</span> w = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">WithAspects</span>();<br />    <span style="color: rgb(43,145,175)">INotifyPropertyChanged</span> c = w <span style="color: rgb(0,0,255)">as</span> <span style="color: rgb(43,145,175)">INotifyPropertyChanged</span>;<br />    c.PropertyChanged += c_PropertyChanged;<br />    eventFired = <span style="color: rgb(0,0,255)">false</span>;<br />    w.MyProperty = 10;<br />    <span style="color: rgb(43,145,175)">Assert</span>.IsTrue(eventFired);<br />    eventFired = <span style="color: rgb(0,0,255)">false</span>;<br />    w.MyProperty = 10;  <br />    <span style="color: rgb(43,145,175)">Assert</span>.IsFalse(eventFired);<br />    w.MyProperty = 12;<br />    <span style="color: rgb(43,145,175)">Assert</span>.IsTrue(eventFired);<br />}<br /></pre>We have to cast our object to INotifyPropertyChanged in order to get a handle on the event.&nbsp; Not perfect, but better than nothing.&nbsp; Hopefully over time Visual Studio will provide native AOP that <br /><p>deals with this problem, but I wouldn’t hold my breath :-)</p><br /><h4>What about the debugging experience?</h4><br /><p>Debugging still works great.&nbsp; You can set a breakpoint in your code and step through things like you would expect to.</p><br /><h4>What about performance?</h4><br /><p>Aspects slow performance down a fair bit.&nbsp; I did a test with 200,000 property sets/gets using both the normal method and the AOP method.</p><br /><p>The AOP method took 0.265 seconds.&nbsp; The normal method took 0.003s.&nbsp; That’s quite a bit slower.</p><br /><p>But wait, it’s really not that bad.&nbsp; That’s 200,000 property changes I’ve done.&nbsp; And we’re talking about binding – which is a UI related problem.&nbsp; I don’t think anyone is going to notice that 0.2 second different in their UI if they are changed 200,000 property values in one go.&nbsp; I’d suspect there are bigger issues at play there if that was happening.</p><br /><p>So while performance is slower, in the large scale of things, I doubt there will be a human noticeable difference.</p><br /><h4>What about the IL?</h4><br /><p>PostSharp does IL weaving, so what does the IL look like after compilation.&nbsp; Here’s the property after PostSharp has done it’s thing:</p><br /><p><a href="http://lh4.ggpht.com/_5dD_rBQSs2o/SaNod9M1GVI/AAAAAAAAAn4/8qbCWsDxks8/s1600-h/image%5B3%5D.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://lh4.ggpht.com/_5dD_rBQSs2o/SaNoerCKErI/AAAAAAAAAn8/lkBLN22WOwo/image_thumb%5B1%5D.png?imgmax=800" width="502" height="484"></a> </p><br /><p>You can see where it’s wrapped the setter, and how it’s provided the OnEntry and OnSuccess hooks.&nbsp; You’ll also note that there are OnException and OnExit hooks if you have situations that need those [think logging :-)]</p><br /><p>&nbsp;</p><br /><p>So there you have it, an implementation of INotifyPropertyChanged using Aspect Oriented Programming.&nbsp; I hope that all made sense to you and that you found it useful.&nbsp; Comments are welcome, as always, and be aware that I haven’t extensively tested this – it is just sample code, so your mileage may vary. If you do find problems feel free let me know (letting me know the fixes is even more useful).</p>  