---
layout: post
title: Integration Queues in CruiseControl.NET
date: '2007-07-25T21:30:00.000+10:00'
author: Richard Banks
tags:
- readify
- CruiseControl.NET
modified_time: '2007-07-27T13:13:50.876+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-410090783787935525
blogger_orig_url: http://www.richard-banks.org/2007/07/integration-queues-in-cruisecontrolnet.html
---

<a href="http://ccnet.thoughtworks.com/">CruiseControl.NET</a> version 1.3 was recently released and apart from being a native .NET 2.0 application it also included a new feature called <a href="http://confluence.public.thoughtworks.org/display/CCNET/Integration+Queues" target="_blank">integration queues</a>.<br /><br />So how does this work?  Let's say you have a number of projects in CC.NET with dependencies on other projects. Maybe one is a set of libraries common to a number of projects, others might be data layers for different data storage providers (XML files, SQL, etc), others might be web services or user interfaces for different platforms, etc.  It's not an uncommon situation.<br /><br />When this is the case it's common to want to ensure that if ProjectA is built that any projects that use the output from ProjectA are also built.  In CruiseControl this is managed via either a <a href="http://confluence.public.thoughtworks.org/display/CCNET/ForceBuildPublisher" target="_blank">ForceBuildPublisher</a> or a <a href="http://confluence.public.thoughtworks.org/display/CCNET/Project+Trigger" target="_blank">ProjectTrigger</a>.  The ForceBuildPublisher relies on ProjectA triggering a build on all the projects that depend on it.<br /><br />In your ccnet.config project definition you'd have a publishers section that looks something like the following:<br /><pre class="codeblock"><span style="COLOR: rgb(0,0,255)">    &lt;</span><span style="COLOR: rgb(163,21,21)">publishers</span><span style="COLOR: rgb(0,0,255)">&gt;<br />      &lt;</span><span style="COLOR: rgb(163,21,21)">statistics</span><span style="COLOR: rgb(0,0,255)"> /&gt;<br />      &lt;</span><span style="COLOR: rgb(163,21,21)">xmllogger</span><span style="COLOR: rgb(0,0,255)"> /&gt;<br />      &lt;</span><span style="COLOR: rgb(163,21,21)">forcebuild</span><span style="COLOR: rgb(0,0,255)">&gt;<br />        &lt;</span><span style="COLOR: rgb(163,21,21)">project</span><span style="COLOR: rgb(0,0,255)">&gt;</span>ProjectB<span style="COLOR: rgb(0,0,255)">&lt;/</span><span style="COLOR: rgb(163,21,21)">project</span><span style="COLOR: rgb(0,0,255)">&gt;<br />      &lt;/</span><span style="COLOR: rgb(163,21,21)">forcebuild</span><span style="COLOR: rgb(0,0,255)">&gt;<br />      &lt;</span><span style="COLOR: rgb(163,21,21)">forcebuild</span><span style="COLOR: rgb(0,0,255)">&gt;<br />        &lt;</span><span style="COLOR: rgb(163,21,21)">project</span><span style="COLOR: rgb(0,0,255)">&gt;</span>ProjectD<span style="COLOR: rgb(0,0,255)">&lt;/</span><span style="COLOR: rgb(163,21,21)">project</span><span style="COLOR: rgb(0,0,255)">&gt;<br />      &lt;/</span><span style="COLOR: rgb(163,21,21)">forcebuild</span><span style="COLOR: rgb(0,0,255)">&gt;<br />    &lt;/</span><span style="COLOR: rgb(163,21,21)">publishers</span><span style="COLOR: rgb(0,0,255)">&gt;</span></pre><br /><br />Now, when ProjectA finishes building, CruiseControl will force a build on projects B and D.  This is not a problem but it relies on projectA knowing which projects rely on it.<br /><br />An alternative to the build publisher is to use a ProjectTrigger.  In this scenario ProjectB monitors the build status of ProjectA.  When ProjectA successfully completes, ProjectB triggers a build.  To set up a projectTrigger, edit your project definition an ccnet.config and create a <a href="http://confluence.public.thoughtworks.org/display/CCNET/Trigger+Blocks" target="_blank">trigger block</a> as follows:<br /><br /><pre class="codeblock"><span style="COLOR: rgb(0,0,255)">    &lt;</span><span style="COLOR: rgb(163,21,21)">triggers</span><span style="COLOR: rgb(0,0,255)">&gt;<br />      &lt;</span><span style="COLOR: rgb(163,21,21)">multiTrigger</span><span style="COLOR: rgb(0,0,255)">&gt;<br />        &lt;</span><span style="COLOR: rgb(163,21,21)">triggers</span><span style="COLOR: rgb(0,0,255)">&gt;<br />          &lt;</span><span style="COLOR: rgb(163,21,21)">intervalTrigger</span><span style="COLOR: rgb(0,0,255)"> </span><span style="COLOR: rgb(255,0,0)">seconds</span><span style="COLOR: rgb(0,0,255)">=</span>"<span style="COLOR: rgb(0,0,255)">30</span>"<span style="COLOR: rgb(0,0,255)"> /&gt;<br />          &lt;</span><span style="COLOR: rgb(163,21,21)">projectTrigger</span><span style="COLOR: rgb(0,0,255)"> </span><span style="COLOR: rgb(255,0,0)">project</span><span style="COLOR: rgb(0,0,255)">=</span>"<span style="COLOR: rgb(0,0,255)">ProjectA</span>"<span style="COLOR: rgb(0,0,255)"> /&gt;<br />        &lt;/</span><span style="COLOR: rgb(163,21,21)">triggers</span><span style="COLOR: rgb(0,0,255)">&gt;<br />      &lt;/</span><span style="COLOR: rgb(163,21,21)">multiTrigger</span><span style="COLOR: rgb(0,0,255)">&gt;<br />    &lt;/</span><span style="COLOR: rgb(163,21,21)">triggers</span><span style="COLOR: rgb(0,0,255)">&gt;</span></pre><br />In this way ProjectB now polls for changes to the source respository every 30 seconds and also keeps an eye on ProjectA's build status. To me at least, this seems a lot cleaner in that the build dependency is defined by the project with the dependency, not by the one that is depended upon.<br /><br />Now let's say we have multiple developers where one is working on projectA and the other on projectB.  Both developers commit their changes at the same time.  What will happen?<br /><br />As you would guess, CC.Net detects changes in the source for both projectA and projectB and kicks of builds for each project, concurrently.  Remebering that projectB relies on the output of projectA in the build process, it's very likely that projectB will be using an older version of projectA's output in it's build process.  In situations where you clean out projectA at the start of it's build then projectB may fail as projectA's output is not likely to have been built yet.<br /><br />This is where integration queues come in handy.  An integration queue ensures that only one build occurs at a time, avoiding all the issues that can occur with concurrent builds of dependant projects.  In the example about all we need do is tell projectA and projectB to use the same integration queue and the issue disappears.  In the CruiseControl.NET project definitions add the <em>queue</em> and, optionally, the <em>queuePriority</em> parameters as shown here:<br /><br /><pre class="codeblock"><span style="COLOR: rgb(0,0,255)">  &lt;</span><span style="COLOR: rgb(163,21,21)">project</span><span style="COLOR: rgb(0,0,255)"> </span><span style="COLOR: rgb(255,0,0)">name</span><span style="COLOR: rgb(0,0,255)">=</span>"<span style="COLOR: rgb(0,0,255)">ProjectA</span>"<span style="COLOR: rgb(0,0,255)"> </span><span style="COLOR: rgb(255,0,0)">queue</span><span style="COLOR: rgb(0,0,255)">=</span>"<span style="COLOR: rgb(0,0,255)">MyBuildQueue</span>"<span style="COLOR: rgb(0,0,255)"> </span><span style="COLOR: rgb(255,0,0)">queuePriority</span><span style="COLOR: rgb(0,0,255)">=</span>"<span style="color:#0000ff;">1</span>"<span style="COLOR: rgb(0,0,255)">&gt;</span></pre><br /><br />The queuePriority is not really that relevant when there's just 2 projects that rely on each other, but in situations where you have a chain of 3 or more interdependent projects it can be very useful.<br /><br />For example, if projectC depends on the output of projectA and projectB what happens when a commit is made on projectA?<br /><br />Initially the build queue will be:<br /><ol><li>projectA (building)</li></ol>ProjectC then hits a timer interval and wants to check if projectA has built.  The queue then looks like<br /><ol><li>projectA (building)</li><li>projectC (pending)</li></ol>ProjectB then hits it's timer and also goes into the queue, which becomes<br /><ol><li>projectA (building)</li><li>projectC (pending)</li><li>projectB (pending)</li></ol>This is obviously undesirable as projectC will build twice, the first build against an incorrect version of projectB and the second time triggered by the successful build of projectB.  If we use a queue priority then we can ensure that projectB builds before projectC.  Note that for this to work, the queue priority needs to be a non-zero number and the lowest number gets the earliest queue position.<br /><br />So lets say projectA is priority 1, projectB is priority2 and projectC is priority 3.  Now, when the projectB timer fires it will be placed in the queue before projectC as it has a higher priority.  The queue would then become<br /><ol><li>projectA (building)</li><li>projectB (pending)</li><li>projectC (pending)</li></ol>This way we ensure that projectC always compiles against the latest versions of projectA and projectB as desired.