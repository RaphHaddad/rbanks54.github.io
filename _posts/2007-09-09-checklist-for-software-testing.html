---
layout: post
title: A Checklist for a Software Testing Architecture
date: '2007-09-09T22:56:00.001+10:00'
author: Richard Banks
tags:
- readify
- ".net"
- testing
- open source
- TFS
- agile
- development
modified_time: '2007-09-09T22:56:15.023+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-5141343025660016282
blogger_orig_url: http://www.richard-banks.org/2007/09/checklist-for-software-testing.html
---

<p>Every developer knows that they need to test their code.&#xA0; Of course, just knowing that you need to test doesn't automatically mean that you will.&#xA0; Rigorous testing is often skipped because developers like to, um, develop and, well, testing is yet another one of those pesky details that takes developers away from developing.</p>  <p>After all, everyone knows that if you don't test properly today the maintenance cost for your software tomorrow will be much larger than it needs to be but honestly, why worry about tomorrow when the deadline is now! Right? And if it all falls over, you can just leave and get another job somewhere else.</p>  <p>Hopefully most of you are now shaking your heads at sentiments of the previous paragraph and saying &quot;I'd never think act that&quot; but the general evidence in the industry points to the opposite.&#xA0; It's all too apparent that testing is the poor cousin of development, and often gets left in the corner when project resources are handed out.</p>  <p>This doesn't have to be the case.</p>  <p>Testing, and rigorous testing at that, can be made an integral part of development with little or no impact on the delivery date, while at the same time producing a product of a much higher quality.</p>  <p>In order to do it though you'll need to establish a testing architecture and then ensure it is adhered to.&#xA0; Here's a checklist you can use as a basis for defining a testing architecture for your own team(s).</p>  <h4>1. Have a <a href="http://blogs.msdn.com/steverowe/archive/2005/02/23/378710.aspx" target="_blank">Test Architect</a></h4>  <p>This doesn't have to be a full time role but you need someone to own the testing process and to mentor others in how to test properly.&#xA0; That someone should also write the tricky integration tests, to be the one that configures and maintains the build server test suites, and is the person responsible for ensuring the rest of the team adheres to the testing architecture.</p>  <h4>2. Unit Tests</h4>  <p>Developers must be responsible for writing unit tests for their own code. These should be true *unit* tests and where possible use appropriate <a href="http://en.wikipedia.org/wiki/Dependency_injection" target="_blank">Dependency Injection</a> (aka Inversion of Control) techniques to enable better testing.&#xA0; When using DI and <a href="http://en.wikipedia.org/wiki/Mock_object" target="_blank">mock objects</a>, remember that your aim is to test the interactions between classes.&#xA0; In other words you want to ensure that the class is making the right type of calls with the right parameters at the right time.&#xA0; You&#x2019;re not wanting to do integration testing.&#xA0; Also, don&#x2019;t forget to test for the correct throwing of exceptions as this is often missed.</p>  <p>Also, I try to restrict unit testing to non-interactive system components.&#xA0; In other words don&#x2019;t try to unit test ASPX code behinds, or WPF code-besides, etc &#x2013; they can be covered via functional testing.</p>  <h4>3. Specific Testing at Each Layer</h4>  <p>Write tests that target the various layers in your application.&#xA0; Unit tests for business objects, functional tests for testing the UI, database tests for stored procedures, etc.&#xA0; Don't try writing the &quot;one test to rule them all&quot;.&#xA0; Tests that target multiple application layers are definitely required (in integration testing) but in general keep tests specific to a single layer.</p>  <p>When testing your Data Access layer (especially when using an O/RM) be aware that you are trying to test the database interactions, not the database itself.&#xA0; I&#x2019;d also recommend against rolling your own O/RM (it's a huge undertaking) and using either an open source one (<a href="http://www.nhibernate.org/" target="_blank">nHibernate</a> for example) or a commercial offering with lots of unit testing already completed.&#xA0; You can save yourself a lot (and pain) by doing so.</p>  <p>Testing of the stored procedures in the database can be accomplished via DataDude (<a href="http://msdn2.microsoft.com/en-us/teamsystem/aa718807.aspx" target="_blank">Visual Studio 2005 Team Edition for Database Developers</a>) or you can create your own <a href="http://www.nunit.org/" target="_blank">NUnit</a> test harness.&#xA0; Various other commercial offerings exist that can also help in this area.    <br />Note that if you use NUnit as a test harness you'll likely have a fair bit of setup/teardown work involved.&#xA0; For example you'll probably need to backup/restore the database between test executions, etc.&#xA0; For this reason they are better suited to be part of a nightly test suite instead of being executed every build.</p>  <h4>4. Ensure Unit Tests Pass before Code is Checked In</h4>  <p>Unit tests don't ensure that the tests are useful so it's also good to conduct code reviews.&#xA0; A code review can easily (and should) include the checking of unit test execution and, importantly, that the tests are appropriate.</p>  <h4>5. Use Continuous Integration</h4>  <p>Use a continuous integration build server.&#xA0; Every time a developer commits code into the source control system, the build server immediately gets the latest code, compiles it and runs the unit tests.&#xA0; <a href="http://ccnet.thoughtworks.com/" target="_blank">CruiseControl.NET</a> is great for this and works well against many version control systems like Subversion, Team Foundation Server, Source Safe (bleck!), CVS, SourceGear and many more.&#xB7; For the TFS purists you can also look at using <a href="http://notgartner.wordpress.com/2006/09/18/getting-started-with-tfs-integrator/" target="_blank">TFSIntegrator</a>.</p>  <p>You should ensure that if any unit test fails then the build fails.&#xA0; Make sure that the tests that run as part of the CI build are just unit tests.&#xA0; Don't do any DB/Integration/Web Service tests during a CI build as they are slow processes and you want your CI builds to be fairly quick.&#xA0; Long running tests can be run as part of a nightly test suite.</p>  <h4>6. Set A Code Coverage Target</h4>  <p>A coverage target around 75% to 80% is quite high and helps ensure that as much code as practical gets tested by the unit tests.&#xA0; If you've already got code in place, start with a 5% figure and work your way up from there.</p>  <p>If the target isn't met - fail the build.</p>  <h4>7. Automate Integration Tests &amp; Deployment</h4>  <p>Ensure that the CI server also triggers the creation of a deployment or setup package after each successful build (or nightly if you prefer).&#xA0; Use the output from the deployment package as the basis for running your integration tests.&#xA0; This will prove not only that the code is correct, but that the setup kits are also correct, that uninstalling doesn't leave any nasties around, and that you've included all required 3rd party assemblies.   <br />As part of the automation process you should also be <a href="http://richardsbraindump.blogspot.com/2007/07/using-tfs-source-control-with.html" target="_blank">versioning your code</a> (or <a href="http://tfsnow.wordpress.com/2007/08/30/build-stamping-embedding-build-numbers-in-application-assemblies/" target="_blank">build stamping</a>).&#xA0; Personally, I like to see a build number based on the changeset number from TFS/SubVersion/etc as it makes it easy to tie a build back to the code it was based on.</p>  <h4>8. Do Regular Performance &amp; Load Testing</h4>  <p>As part of the nightly build (weekly at worst) do automated load and performance testing.&#xA0; Track the figures from your performance/load testing over time to determine if the application is within acceptable performance benchmarks.</p>  <p>If someone checks in some really poor code it may well pass all the unit and integration tests you have, but it could cause the performance of your application to go south in a big way.&#xA0; Regular performance benchmarking will help you spot this kind of problem quickly before it becomes a last minute problem.</p>  <p>&#xA0;</p>  <p>These 8 tips should get you well on the way to putting together your own test architecture.&#xA0; Yes, there is a lot of work involved in getting this up and running, however the time and effort expended in doing so for any decent sized project is more than paid for through massively reduced rework, happier customers, and a much better overall product.</p>  <p>Finally, you may be asking, &quot;But what about automated UI testing, <a href="http://www.codinghorror.com/blog/archives/000779.html" target="_blank">usability testing</a>, user acceptance testing, etc?&quot; Well, automated UI testing is an iffy proposition for me.&#xA0; There can be some massive cost savings in not having a person sit down and manually re-execute every UI test every time you make a change just to ensure you didn't break anything, but if you've got great coverage at every level underneath the UI and you've got a good suite of integration tests, then you've already provided yourself with a good amount of QA insurance and this probably isn't required.&#xA0; Further the cost of writing and, more importantly, maintaining regression tests for the UI is quite high.&#xA0; Many of the open source or low to mid-range commercial offerings provide some of the answers, but none of them provide all.&#xA0; The best tool on the market at this time is Mercury, but it's very expensive and you really need to think about the ROI of investing in UI automation versus keeping your testers doing it by hand.</p>  <p>The other types of testing (usability, UAT, etc) are very important parts of the QA cycle but these are rarely executed test types and not well suited to a regular, automated testing architecture that can be integrated into your development process.</p>  <p>Finally, you'll note that I haven't really talked about tools to support this architecture.&#xA0; That's because your budget, technology, team skills, project type and environment will be different to mine, which will be different to the next person to read this article and so on.&#xA0; All I can say is that you should take the time do some investigation and find the right tools with the right ROI for your needs.</p> 