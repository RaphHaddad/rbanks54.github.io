---
layout: post
title: Code Contracts
date: '2009-02-27T09:58:00.001+11:00'
author: Richard Banks
tags:
- ".net"
- code contracts
- development
modified_time: '2009-02-27T09:58:34.283+11:00'
thumbnail: http://lh5.ggpht.com/_5dD_rBQSs2o/SacemAXFywI/AAAAAAAAAoE/AldlbY02_us/s72-c/clip_image002_thumb%5B3%5D.jpg?imgmax=800
blogger_id: tag:blogger.com,1999:blog-13321238.post-4056359861939532441
blogger_orig_url: http://www.richard-banks.org/2009/02/code-contracts.html
---

<p>So apparently we’re meant to be getting support for code contracts in .NET 4.0 which is great.&nbsp; But why wait until then when you can go to <a href="http://research.microsoft.com/en-us/projects/contracts/">http://research.microsoft.com/en-us/projects/contracts/</a> and grab it for VS2008 now :-) <h4>Why code contracts?</h4> <p>“So, what’s the big deal with code contracts?” you might ask.&nbsp; How are contracts different to just a bunch of asserts?&nbsp; It’s a little too big to cover here, but contracts are intended to make your code more explicit, and thus a lot easier to test and verify (including at compile time) and more stable in that terms of behaviour as well.&nbsp; <p>Where this gets interesting is that you can define contracts on interfaces.&nbsp; So now, you can not only have an expectation that an inheriting class will implement all the methods and properties defined by the interface itself, but that the class will also ensure certain things occur (such as returning non null values for instance).&nbsp; You can also ensure that classes using the interface call the methods on it with specific expectations met (such as always providing non null parameters, etc). <h4>Contracts on Interfaces!</h4> <p>So, I’ve just started playing around with this stuff now and I had a quick look at the sample for code contracts where interfaces are concerned.&nbsp; Here’s the code:<pre class="code">  <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">Program<br /></span>  {<br />    <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">void</span> Main(<span style="color: rgb(0,0,255)">string</span>[] args)<br />    {<br />      <span style="color: rgb(0,0,255)">var</span> f1 = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">FooImplementation1</span>();<br />      <span style="color: rgb(0,0,255)">int</span> r1 = f1.Foo(0);<br />      <span style="color: rgb(43,145,175)">Contract</span>.Assert(r1 &gt; 0);<br /><br />      <span style="color: rgb(43,145,175)">IFoo</span> f2 = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">FooImplementation2</span>();<br />      <span style="color: rgb(0,0,255)">int</span> r2 = f2.Foo(1);<br />    }<br />  }<br /><br />  [<span style="color: rgb(43,145,175)">ContractClass</span>(<span style="color: rgb(0,0,255)">typeof</span>(<span style="color: rgb(43,145,175)">IFooContract</span>))]<br /><span style="color: rgb(0,0,255)">  interface</span> <span style="color: rgb(43,145,175)">IFoo<br /></span>  {<br /><span style="color: rgb(0,0,255)">    int</span> Foo(<span style="color: rgb(0,0,255)">int</span> x);<br />  }<br /><br />  [<span style="color: rgb(43,145,175)">ContractClassFor</span>(<span style="color: rgb(0,0,255)">typeof</span>(<span style="color: rgb(43,145,175)">IFoo</span>))]<br />  <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">IFooContract</span> : <span style="color: rgb(43,145,175)">IFoo<br /></span>  {<br />    <span style="color: rgb(0,0,255)">int</span> <span style="color: rgb(43,145,175)">IFoo</span>.Foo(<span style="color: rgb(0,0,255)">int</span> x)<br />    {<br />      <span style="color: rgb(43,145,175)">Contract</span>.Requires(x &gt; 0);<br />      <span style="color: rgb(43,145,175)">Contract</span>.Ensures(<span style="color: rgb(43,145,175)">Contract</span>.Result&lt;<span style="color: rgb(0,0,255)">int</span>&gt;() &gt; 0);<br /><br />      <span style="color: rgb(0,0,255)">throw</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">NotImplementedException</span>();<br />    }<br />  }<br /><br />  <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">FooImplementation1</span> : <span style="color: rgb(43,145,175)">IFoo<br /></span>  {<br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">int</span> Foo(<span style="color: rgb(0,0,255)">int</span> x)<br />    {<br />      <span style="color: rgb(0,0,255)">return</span> x;<br />    }<br />  }<br /><br />  <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">FooImplementation2</span> : <span style="color: rgb(43,145,175)">IFoo<br /></span>  {<br />    <span style="color: rgb(128,128,128)">///</span><span style="color: rgb(0,128,0)"> </span><span style="color: rgb(128,128,128)">&lt;summary&gt;<br /></span>    <span style="color: rgb(128,128,128)">///</span><span style="color: rgb(0,128,0)"> Bad implementation of IFoo.Foo which does not always satisfy post condition.<br /></span>    <span style="color: rgb(128,128,128)">///</span><span style="color: rgb(0,128,0)"> </span><span style="color: rgb(128,128,128)">&lt;/summary&gt;<br /></span>    <span style="color: rgb(0,0,255)">int</span> <span style="color: rgb(43,145,175)">IFoo</span>.Foo(<span style="color: rgb(0,0,255)">int</span> x)<br />    {<br />      <span style="color: rgb(0,0,255)">return</span> x - 1;<br />    }<br />  }</pre><a href="http://11011.net/software/vspaste"></a><br /><p>When you compile this, it will throw a few warnings at you:<br /><p><a href="http://lh6.ggpht.com/_5dD_rBQSs2o/Sacek3-L7oI/AAAAAAAAAoA/j7G_yhaH9Dg/s1600-h/clip_image002%5B6%5D.jpg"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image002" border="0" alt="clip_image002" src="http://lh5.ggpht.com/_5dD_rBQSs2o/SacemAXFywI/AAAAAAAAAoE/AldlbY02_us/clip_image002_thumb%5B3%5D.jpg?imgmax=800" width="454" height="61"></a><br /><p>The first warning relates to this line<pre class="code">      <span style="color: rgb(0,0,255)">int</span> r1 = f1.Foo(0);<br /></pre><a href="http://11011.net/software/vspaste"></a><br /><p>Which violates the contract that requires the parameter be greater than zero.<br /><p>The second warning is related to the second IFoo implementation, where this method:<pre class="code">    <span style="color: rgb(0,0,255)">int</span> <span style="color: rgb(43,145,175)">IFoo</span>.Foo(<span style="color: rgb(0,0,255)">int</span> x)<br />    {<br />      <span style="color: rgb(0,0,255)">return</span> x - 1;<br />    }<br /></pre><a href="http://11011.net/software/vspaste"></a><br /><p>can’t prove that it will return a value greater than zero.&nbsp; The compiler even makes a suggestion that the Requires contract should be that (x-1) &gt; 0.&nbsp; Not bad.<br /><p>As for the implementation, since we can’t put code in interface declarations the tool uses the [ContractClassFor] attribute to provide the contract implementations.&nbsp; What you will also note is that the contract class uses an explicit interface implementation and also uses the same ContractClassFor attribute to indicate that it is the contract implementation for IFoo.&nbsp; BTW, the return values from the contract class are completely ignored.<br /><p>P.S. You can put contracts on abstract methods in base classes as well using the same technique.<br /><p>That’s some very nice stuff, and we don’t even have to wait for the CLR v4.0 release.&nbsp; We can do this stuff today!</p>  