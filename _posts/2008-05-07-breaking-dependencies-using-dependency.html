---
layout: post
title: Breaking Dependencies using Dependency Injection
date: '2008-05-07T13:05:00.001+10:00'
author: Richard Banks
tags:
- readify
- ".net"
- testing
- development
modified_time: '2008-05-07T13:05:30.164+10:00'
blogger_id: tag:blogger.com,1999:blog-13321238.post-7841774969302878737
blogger_orig_url: http://www.richard-banks.org/2008/05/breaking-dependencies-using-dependency.html
---

<p>Let's assume you've done some reading recently and heard talk of this Loosely Coupled Architecture thing and how it's meant to help keep an application maintainable, make it more readily changeable and will assist in the creation of unit tests .&nbsp;&nbsp; You know that it's the right way to go and you can see all the benefits of it. You even think "I should do this on that application at work", but every time you look at the code at work and wonder what space monkeys were hired to write the code in the first place and you think about how tightly bound everything is it all starts to look too hard, so you give up and get back to working with things as they because the problem seems insurmountable.</p> <p>Now a loosely coupled architecture is at it's heart just another way of saying object oriented design.&nbsp; I'm sure you'll remember from when you learnt all that Object Oriented Programming stuff that there are some basic principle for OO Programming, namely:</p> <blockquote> <p>Abstraction, Encapsulation, Polymorphism and Inheritance</p></blockquote> <p>And there are also some <a href="http://www.surfscranton.com/Architecture/ObjectOrientedDesignPrinciples.htm" target="_blank">OO Design principles</a> that sit alongside the OOP principles:</p> <blockquote> <p>Encapsulate what changes</p> <p>Favour composition over inheritance</p> <p>Program to interfaces not implementations</p> <p>Depend on abstractions, not concrete classes (dependency inversion)</p> <p>A class should have only one reason to change (single responsibility)</p></blockquote> <p>Your work code and the "this problem is too big" feeling doesn't have to be the case.&nbsp; It's just an indication that you've got legacy code and that it isn't well designed.&nbsp; The good news is that by following some basic steps you can refactor a legacy, tightly-bound application into one with a loosely coupled architecture, though it will take some time (think many months, not weeks).</p> <p>There are two basic methods for doing this.&nbsp; The first is Extract &amp; Override (see <a href="http://weblogs.asp.net/rosherove/articles/DependencyIssues.aspx" target="_blank">Roy Osherove's blog entry</a>) and the other is Dependency Injection.&nbsp; This is what I'll focus on here.</p> <p>First, let's have a look at some code from a simple sales application:</p><pre class="codeblock">    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">Sale<br /></span>    {<br />        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">SaleLine</span>&gt; saleLines = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">SaleLine</span>&gt;();<br />        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">decimal</span> totalTax;<br />        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(0,0,255)">decimal</span> totalValue;<br>        ...<br>        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">bool</span> Add(<span style="color: rgb(0,0,255)">string</span> inputLine)<br />        {<br />            <span style="color: rgb(43,145,175)">SaleLine</span> saleLine;<br /><br />            saleLine = <span style="color: rgb(43,145,175)">InputParser</span>.ProcessInput(inputLine);<br />            <span style="color: rgb(0,0,255)">if</span> (saleLine == <span style="color: rgb(0,0,255)">null</span>)<br />                <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(0,0,255)">false</span>;<br>            saleLines.Add(saleLine); <br>            ...</pre><br /><p>Here we see that a sale has multiple sale lines associated with it.&nbsp; Pretty normal, and something you'll see in many code bases the world over, but we're breaking some of the OOD rules - we're programming to implementations not interfaces and we're using a static method (on the InputParser) which means we're tightly coupled between the Sale object and the SaleLine object.</p><br /><p>We're also doing something else that's a no-no.&nbsp; The Add method is coordinating a whole lot of work to convert an input string into a SaleLine object before adding it to the saleLines collection, whichmeans the class does more than one thing.&nbsp; </p><br /><p>Let's have a quick look at the ProcessInput method on the InputParser class as well</p><pre class="codeblock">        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(43,145,175)">SaleLine</span> ProcessInput(<span style="color: rgb(0,0,255)">string</span> input)<br />        {<br />            <span style="color: rgb(43,145,175)">SaleLine</span> saleLine;<br />            ...<br />            <span style="color: rgb(0,128,0)">// create the sale line<br /></span>            saleLine = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">SaleLine</span>(quantity, name, price);<br />            <span style="color: rgb(0,0,255)">return</span> saleLine;<br />        }<br /></pre><br /><p>What we have here is another tight coupling.&nbsp; We're creating saleline objects from within the method (the new SaleLine() call) which means we have a tight dependency between the saleline class and the InputParser class.&nbsp; If we wanted to change the SaleLine to some other class, we'd have some refactoring to do.</p><br /><p>&nbsp;</p><br /><p>So let's make some changes...</p><br /><p>Lets start by creating interfaces for all of our concrete classes, for example:</p><pre class="codeblock">    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">Sale</span> : <span style="color: rgb(43,145,175)">ISale<br /></span>    {<br />        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">ISaleLine</span>&gt; saleLines = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">ISaleLine</span>&gt;();</pre><br /><p>Now, if our definition of what a sale line is changes we don't have to make any changes in the Sale object.&nbsp; Nice.</p><br /><p>Let's also change the input parser so it doesn't create Sale objects directly.&nbsp; We should do that through the use of a <a href="http://en.wikipedia.org/wiki/Factory_method_pattern" target="_blank">factory pattern</a> implementation, such as the following:</p><pre class="codeblock">    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">SaleLineFactory</span> : <span style="color: rgb(43,145,175)">ISaleLineFactory<br /></span>    {<br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(43,145,175)">ISaleLine</span> GetNewSaleLine(<span style="color: rgb(0,0,255)">int</span> lineQuantity, <span style="color: rgb(0,0,255)">string</span> name, <span style="color: rgb(0,0,255)">decimal</span> unitPrice)<br />        {<br />            <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">SaleLine</span>(lineQuantity, name, unitPrice);<br />        }<br />    }<br /></pre><br /><p>And in our InputParser we change the code as follows:</p><pre class="codeblock">            saleLine = saleLineFactory.GetNewSaleLine(quantity, productName, price);</pre><br /><p>Good. So now we're not actually creating the SaleLine object directly in our code.&nbsp; This is a good thing as it breaks the tight coupling between the classes, but doesn't it just move the dependency from the SaleLine class to the SaleLineFactory class?</p><br /><p>It would if we just added saleLineFactory = new SaleLineFactory() to the InputParser, but not if we pass an instance of the saleLineFactory class to the InputParser.&nbsp; This is the <a href="http://en.wikipedia.org/wiki/Dependency_injection" target="_blank">Dependency Injection</a> pattern at work.</p><br /><p>Now, while we're working in the InputParser class we also have the opportunity to fix another tight coupling.&nbsp; That between the Sale class and the InputParser.&nbsp; Let's change the input parser so that we're no longer a static class, but rather a normal class (in a real world situation this could be complex) and let's pass to the ProcessInput method the Sale we want the new line to be added to.&nbsp; We can then change the sale object so that it's Add method just adds ISaleLine objects instead of being passed a string and then calling to the parser.&nbsp; Something like this:</p><pre class="codeblock">    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">Sale</span> : <span style="color: rgb(43,145,175)">ISale<br /></span>    {<br />        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">ISaleLine</span>&gt; saleLines = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">List</span>&lt;<span style="color: rgb(43,145,175)">ISaleLine</span>&gt;();<br>        ...<br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">bool</span> Add(<span style="color: rgb(43,145,175)">ISaleLine</span> saleLine)<br />        {<br />            <span style="color: rgb(0,0,255)">if</span> (saleLine == <span style="color: rgb(0,0,255)">null</span>)<br />                <span style="color: rgb(0,0,255)">return</span> <span style="color: rgb(0,0,255)">false</span>;<br />            saleLines.Add(saleLine);<br /><br />    <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">class</span> <span style="color: rgb(43,145,175)">InputParser</span> : <span style="color: rgb(43,145,175)">IInputParser </span><br />    {<br />        <span style="color: rgb(0,0,255)">private</span> <span style="color: rgb(43,145,175)">ISaleLineFactory</span> saleLineFactory;<br />        <span style="color: rgb(0,0,255)">public</span> InputParser(<span style="color: rgb(43,145,175)">ISaleLineFactory</span> saleLineFactory)<br />        {<br />            <span style="color: rgb(0,0,255)">this</span>.saleLineFactory = saleLineFactory;<br />        }<br /><br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> ProcessInput(<span style="color: rgb(0,0,255)">string</span> input, <span style="color: rgb(43,145,175)">ISale</span> sale)<br />        {<br />            <span style="color: rgb(43,145,175)">ISaleLine</span> saleLine;<br />            ...<br />            saleLine = saleLineFactory.GetNewSaleLine(quantity, name, price);<br />            sale.Add(saleLine);<br />            <span style="color: rgb(0,0,255)">return</span>;<br />        }</pre><br /><p>Much cleaner.&nbsp; We now have no hard dependencies between our classes and we are programming to interfaces not concrete classes.&nbsp; </p><br /><p>But we're not done yet.&nbsp; We still have to create a saleLineFactory class, an InputParser class, a Sale object, etc for us to be able to do any real work.&nbsp; Where/when/how do we do all of this?</p><br /><p>This is where an Inversion of Control (IoC) container can come in handy.&nbsp; We could just create these objects manually at application startup, but using an IoC container is much easier.&nbsp; An IoC container lets you map interfaces to classes, i.e. to say that InterfaceX is implemented by ClassY and the container will resolve these dependencies for you.&nbsp; Most IoC containers let you do a whole lot more as well (Aspects for example).&nbsp; For this example we'll use the <a href="http://www.castleproject.org/container/index.html" target="_blank">Castle Windsor</a> container to control our object creation for us:</p><pre class="codeblock">        <span style="color: rgb(0,0,255)">static</span> <span style="color: rgb(0,0,255)">void</span> Main(<span style="color: rgb(0,0,255)">string</span>[] args)<br />        {<br />            <span style="color: rgb(43,145,175)">IWindsorContainer</span> container = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">WindsorContainer</span>(<span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">XmlInterpreter</span>());<br /><br />            <span style="color: rgb(43,145,175)">IInputControl</span> inputter = container.Resolve&lt;<span style="color: rgb(43,145,175)">IInputControl</span>&gt;();<br />            <span style="color: rgb(43,145,175)">IInputParser</span> parser = container.Resolve&lt;<span style="color: rgb(43,145,175)">IInputParser</span>&gt;();<br /><br />            <span style="color: rgb(43,145,175)">ISale</span> sale;<br />            <span style="color: rgb(0,0,255)">string</span> input;<br /><br />            sale = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">Sale</span>();<br />            input = inputter.GetInput();<br />            <span style="color: rgb(0,0,255)">while</span> (!inputter.EOF())<br />            {<br />                parser.ProcessInput(input, sale);<br />                input = inputter.GetInput();<br />            }<br /></pre><br /><p>And here's the configuration file:</p><pre class="codeblock"><span style="color: rgb(0,0,255)">    &lt;</span><span style="color: rgb(163,21,21)">configSections</span><span style="color: rgb(0,0,255)">&gt;<br />        &lt;</span><span style="color: rgb(163,21,21)">section</span><span style="color: rgb(0,0,255)"> </span><span style="color: rgb(255,0,0)">name</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">castle</span>"<span style="color: rgb(0,0,255)"> </span><span style="color: rgb(255,0,0)">type</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">Castle.Windsor.Configuration.AppDomain.CastleSectionHandler, Castle.Windsor</span>"<span style="color: rgb(0,0,255)"> /&gt;<br />    &lt;/</span><span style="color: rgb(163,21,21)">configSections</span><span style="color: rgb(0,0,255)">&gt;<br /><br />    &lt;</span><span style="color: rgb(163,21,21)">castle</span><span style="color: rgb(0,0,255)">&gt;<br />        &lt;</span><span style="color: rgb(163,21,21)">components</span><span style="color: rgb(0,0,255)">&gt;<br />            &lt;</span><span style="color: rgb(163,21,21)">component</span><span style="color: rgb(0,0,255)"> </span><span style="color: rgb(255,0,0)">id</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">prompt.input</span>"<span style="color: rgb(0,0,255)"> </span><span style="color: rgb(255,0,0)">service</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">Sales.IInputControl, Sales</span>"<br /><span style="color: rgb(0,0,255)">                </span><span style="color: rgb(255,0,0)">type</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">Sales.PromptInputControl, Sales</span>"<span style="color: rgb(0,0,255)"> /&gt;<br /></span><span style="color: rgb(0,0,255)">            &lt;</span><span style="color: rgb(163,21,21)">component</span><span style="color: rgb(0,0,255)"> </span><span style="color: rgb(255,0,0)">id</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">input.parser</span>"<span style="color: rgb(0,0,255)"> </span><span style="color: rgb(255,0,0)">service</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">Sales.IInputParser, Sales</span>"<br /><span style="color: rgb(0,0,255)">                </span><span style="color: rgb(255,0,0)">type</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">Sales.InputParser, Sales</span>"<span style="color: rgb(0,0,255)"> /&gt;<br />            &lt;</span><span style="color: rgb(163,21,21)">component</span><span style="color: rgb(0,0,255)"> </span><span style="color: rgb(255,0,0)">id</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">salelinefactory</span>"<span style="color: rgb(0,0,255)"> </span><span style="color: rgb(255,0,0)">service</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">Sales.ISaleLineFactory, Sales</span>"<br /><span style="color: rgb(0,0,255)">                </span><span style="color: rgb(255,0,0)">type</span><span style="color: rgb(0,0,255)">=</span>"<span style="color: rgb(0,0,255)">Sales.SaleLineFactory, Sales</span>"<span style="color: rgb(0,0,255)"> /&gt;<br />        &lt;/</span><span style="color: rgb(163,21,21)">components</span><span style="color: rgb(0,0,255)">&gt;<br />    &lt;/</span><span style="color: rgb(163,21,21)">castle</span><span style="color: rgb(0,0,255)">&gt;</span></pre><br /><p>Now the astute among you will immediately ask why I didn't put the Sale or SaleLine objects into the container?&nbsp; The answer is fairly simple - they're not good candidates for objects to place in the container.&nbsp; You want to put things in the container that are service classes, not data classes.&nbsp; The definition of a sale and saleline will be fairly static, plus the use of the ISaleLineFactory lets us control which ISaleLine implementation we want to use. it's also why the factory is one of the classes the IoC container is aware of - a factory class is a service that the application uses.</p><br /><p>You might also ask, why am I using sale = new Sale() in my sample code?&nbsp; Well, I could have written an ISaleFactory and used that instead (and in a real world system it's what I'd recommend) but this is a sample app, so I beg your forgiveness :-)</p><br /><p>Finally, the really astute amongst you will notice that I never call Resolve for the ISaleLineFactory interface and I don't provide parameters for the IInputParser class when it's resolved.&nbsp; So how does it get into the input parser?&nbsp; Well, the cool thing about the Windsor container is that it will automatically scan the constructors for classes it's aware of, and if that constructor has a dependency (i.e. the ISaleLineFactory interface) then the container will automatically instantiate an object for that interface and pass it through.</p><br /><p>This makes managing dependencies and instantiation of classes so much simpler, and in large applications this is invaluable.</p><br /><p>&nbsp;</p><br /><p>Now there is one other side effect to these changes.&nbsp; By having loosely coupled objects writing unit tests is a lot easier now, and they are genuine unit tests, in other words they test one thing and one thing only.&nbsp; Previously I would have had an input parser test as follows:</p><pre class="codeblock">        [<span style="color: rgb(43,145,175)">Test</span>]<br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> ParseACorrectLine()<br />        {<br />            saleLine = <span style="color: rgb(43,145,175)">InputParser</span>.ProcessInput(<span style="color: rgb(163,21,21)">"1 book at 12.49"</span>);<br />            <span style="color: rgb(43,145,175)">Assert</span>.IsNotNull(saleLine);<br />            <span style="color: rgb(43,145,175)">Assert</span>.AreEqual(<span style="color: rgb(163,21,21)">"book"</span>,saleLine.ProductName);<br />            <span style="color: rgb(43,145,175)">Assert</span>.AreEqual(1, saleLine.Quantity);<br />            <span style="color: rgb(43,145,175)">Assert</span>.AreEqual(12.49m, saleLine.Price);<br />        }<br /></pre><br /><p>&nbsp;</p><br /><p>But this is effectively an integration test.&nbsp; It's testing that the parser and the saleline classes are both working and working together properly.&nbsp; Not an ideal situation.</p><br /><p>But with a loosely coupled design I can now use mocking and write a test as follows:</p><a href="http://11011.net/software/vspaste"></a><pre class="codeblock">        [<span style="color: rgb(43,145,175)">TestMethod</span>]<br />        <span style="color: rgb(0,0,255)">public</span> <span style="color: rgb(0,0,255)">void</span> ParseACorrectLine()<br />        {<br />            mocksRepository = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">MockRepository</span>();<br />            saleLineFactory = mocksRepository.DynamicMock&lt;<span style="color: rgb(43,145,175)">ISaleLineFactory</span>&gt;();<br />            sale = mocksRepository.DynamicMock&lt;<span style="color: rgb(43,145,175)">ISale</span>&gt;();<br />            parser = <span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">InputParser</span>(display, saleLineFactory);<br />            <span style="color: rgb(43,145,175)">Expect</span>.Call(saleLineFactory.GetNewSaleLine(1,<span style="color: rgb(163,21,21)">"book"</span>,12.49m)).Return(<span style="color: rgb(0,0,255)">new</span> <span style="color: rgb(43,145,175)">SaleLine</span>(1,<span style="color: rgb(163,21,21)">"book"</span>,12.49m));<br />            mocksRepository.ReplayAll();<br />            parser.ProcessInput(<span style="color: rgb(163,21,21)">"1 book at 12.49"</span>, sale);<br />            mocksRepository.VerifyAll();<br />        }</pre><br /><p>Now my test is checking that the interactions between the InputParser and the other classes are correct, not that the other classes are functioning correctly as well (which is what the first test did).&nbsp; Note that the return of a new SaleLine object is just there to provide a return value for the call to the saleline factory.&nbsp; Not having it would cause the test to fail.</p><br /><p>&nbsp;</p><br /><p>Hopefully this is enough to get you started on improving that crappy code you have to work with every day and making it a more loosely coupled application, and as always I'd love some feedback :-)</p>  